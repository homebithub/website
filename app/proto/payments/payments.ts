// @generated by protobuf-ts 2.11.1 with parameter long_type_string
// @generated from protobuf file "payments/payments.proto" (package "payments", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../google/protobuf/timestamp";
// ── Domain messages ─────────────────────────────────────

/**
 * @generated from protobuf message payments.SubscriptionPlan
 */
export interface SubscriptionPlan {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: int64 price_amount = 4
     */
    priceAmount: string;
    /**
     * @generated from protobuf field: string billing_cycle = 5
     */
    billingCycle: string;
    /**
     * @generated from protobuf field: string profile_type = 6
     */
    profileType: string;
    /**
     * @generated from protobuf field: int32 trial_days = 7
     */
    trialDays: number;
    /**
     * @generated from protobuf field: int32 display_order = 8
     */
    displayOrder: number;
    /**
     * @generated from protobuf field: bool is_active = 9
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: int32 max_profiles = 10
     */
    maxProfiles: number;
    /**
     * @generated from protobuf field: int32 max_applications = 11
     */
    maxApplications: number;
    /**
     * @generated from protobuf field: int32 max_hires = 12
     */
    maxHires: number;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 13
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 14
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message payments.Subscription
 */
export interface Subscription {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string profile_id = 3
     */
    profileId: string;
    /**
     * @generated from protobuf field: string profile_type = 4
     */
    profileType: string;
    /**
     * @generated from protobuf field: string plan_id = 5
     */
    planId: string;
    /**
     * @generated from protobuf field: string status = 6
     */
    status: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp current_period_start = 7
     */
    currentPeriodStart?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp current_period_end = 8
     */
    currentPeriodEnd?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp trial_end = 9
     */
    trialEnd?: Timestamp;
    /**
     * @generated from protobuf field: bool cancel_at_period_end = 10
     */
    cancelAtPeriodEnd: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp cancelled_at = 11
     */
    cancelledAt?: Timestamp;
    /**
     * @generated from protobuf field: payments.SubscriptionPlan plan = 12
     */
    plan?: SubscriptionPlan;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 13
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 14
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message payments.Payment
 */
export interface Payment {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string profile_id = 3
     */
    profileId: string;
    /**
     * @generated from protobuf field: string profile_type = 4
     */
    profileType: string;
    /**
     * @generated from protobuf field: string subscription_id = 5
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: int64 amount = 6
     */
    amount: string;
    /**
     * @generated from protobuf field: string currency = 7
     */
    currency: string;
    /**
     * @generated from protobuf field: string status = 8
     */
    status: string;
    /**
     * @generated from protobuf field: string payment_method = 9
     */
    paymentMethod: string;
    /**
     * @generated from protobuf field: string phone_number = 10
     */
    phoneNumber: string;
    /**
     * @generated from protobuf field: string merchant_transaction_id = 11
     */
    merchantTransactionId: string;
    /**
     * @generated from protobuf field: string fingo_transaction_id = 12
     */
    fingoTransactionId: string;
    /**
     * @generated from protobuf field: string mpesa_receipt_number = 13
     */
    mpesaReceiptNumber: string;
    /**
     * @generated from protobuf field: string failure_reason = 14
     */
    failureReason: string;
    /**
     * @generated from protobuf field: int32 retry_count = 15
     */
    retryCount: number;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp paid_at = 16
     */
    paidAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 17
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 18
     */
    updatedAt?: Timestamp;
}
// ── Plan RPCs ───────────────────────────────────────────

/**
 * @generated from protobuf message payments.GetPlansRequest
 */
export interface GetPlansRequest {
}
/**
 * @generated from protobuf message payments.GetPlansResponse
 */
export interface GetPlansResponse {
    /**
     * @generated from protobuf field: repeated payments.SubscriptionPlan plans = 1
     */
    plans: SubscriptionPlan[];
}
/**
 * @generated from protobuf message payments.GetPlanRequest
 */
export interface GetPlanRequest {
    /**
     * @generated from protobuf field: string plan_id = 1
     */
    planId: string;
}
/**
 * @generated from protobuf message payments.GetPlanResponse
 */
export interface GetPlanResponse {
    /**
     * @generated from protobuf field: payments.SubscriptionPlan plan = 1
     */
    plan?: SubscriptionPlan;
}
// ── Subscription RPCs ───────────────────────────────────

/**
 * @generated from protobuf message payments.CreateSubscriptionRequest
 */
export interface CreateSubscriptionRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string plan_id = 2
     */
    planId: string;
    /**
     * @generated from protobuf field: string profile_id = 3
     */
    profileId: string;
    /**
     * @generated from protobuf field: string profile_type = 4
     */
    profileType: string;
}
/**
 * @generated from protobuf message payments.CreateSubscriptionResponse
 */
export interface CreateSubscriptionResponse {
    /**
     * @generated from protobuf field: payments.Subscription subscription = 1
     */
    subscription?: Subscription;
}
/**
 * @generated from protobuf message payments.GetSubscriptionRequest
 */
export interface GetSubscriptionRequest {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetSubscriptionResponse
 */
export interface GetSubscriptionResponse {
    /**
     * @generated from protobuf field: payments.Subscription subscription = 1
     */
    subscription?: Subscription;
}
/**
 * @generated from protobuf message payments.GetMySubscriptionRequest
 */
export interface GetMySubscriptionRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetMySubscriptionResponse
 */
export interface GetMySubscriptionResponse {
    /**
     * @generated from protobuf field: payments.Subscription subscription = 1
     */
    subscription?: Subscription;
}
/**
 * @generated from protobuf message payments.ListMySubscriptionsRequest
 */
export interface ListMySubscriptionsRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.ListMySubscriptionsResponse
 */
export interface ListMySubscriptionsResponse {
    /**
     * @generated from protobuf field: repeated payments.Subscription subscriptions = 1
     */
    subscriptions: Subscription[];
}
/**
 * @generated from protobuf message payments.CancelSubscriptionRequest
 */
export interface CancelSubscriptionRequest {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.CancelSubscriptionResponse
 */
export interface CancelSubscriptionResponse {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * @generated from protobuf message payments.CheckSubscriptionAccessRequest
 */
export interface CheckSubscriptionAccessRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.CheckSubscriptionAccessResponse
 */
export interface CheckSubscriptionAccessResponse {
    /**
     * @generated from protobuf field: bool has_access = 1
     */
    hasAccess: boolean;
    /**
     * @generated from protobuf field: string status = 2
     */
    status: string; // active, trial, past_due, suspended, cancelled, none
    /**
     * @generated from protobuf field: string subscription_id = 3
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expires_at = 4
     */
    expiresAt?: Timestamp;
    /**
     * @generated from protobuf field: bool is_trial = 5
     */
    isTrial: boolean;
    /**
     * @generated from protobuf field: bool is_early_adopter = 6
     */
    isEarlyAdopter: boolean;
    /**
     * @generated from protobuf field: int32 days_remaining = 7
     */
    daysRemaining: number;
    /**
     * @generated from protobuf field: string message = 8
     */
    message: string; // Human-readable message about subscription status
}
// ── Payment RPCs ────────────────────────────────────────

/**
 * @generated from protobuf message payments.CreateSubscriptionCheckoutRequest
 */
export interface CreateSubscriptionCheckoutRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string plan_id = 2
     */
    planId: string;
    /**
     * @generated from protobuf field: string phone_number = 3
     */
    phoneNumber: string;
    /**
     * @generated from protobuf field: string profile_id = 4
     */
    profileId: string;
    /**
     * @generated from protobuf field: string profile_type = 5
     */
    profileType: string;
}
/**
 * @generated from protobuf message payments.CreateSubscriptionCheckoutResponse
 */
export interface CreateSubscriptionCheckoutResponse {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string payment_id = 2
     */
    paymentId: string;
    /**
     * @generated from protobuf field: string transaction_id = 3
     */
    transactionId: string;
    /**
     * @generated from protobuf field: string status = 4
     */
    status: string;
    /**
     * @generated from protobuf field: string message = 5
     */
    message: string;
    /**
     * @generated from protobuf field: int64 amount = 6
     */
    amount: string;
    /**
     * @generated from protobuf field: payments.SubscriptionPlan plan = 7
     */
    plan?: SubscriptionPlan;
}
/**
 * @generated from protobuf message payments.InitiatePaymentRequest
 */
export interface InitiatePaymentRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string subscription_id = 2
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string phone_number = 3
     */
    phoneNumber: string;
    /**
     * @generated from protobuf field: int64 amount = 4
     */
    amount: string;
}
/**
 * @generated from protobuf message payments.InitiatePaymentResponse
 */
export interface InitiatePaymentResponse {
    /**
     * @generated from protobuf field: string payment_id = 1
     */
    paymentId: string;
    /**
     * @generated from protobuf field: string transaction_id = 2
     */
    transactionId: string;
    /**
     * @generated from protobuf field: string status = 3
     */
    status: string;
    /**
     * @generated from protobuf field: string message = 4
     */
    message: string;
}
/**
 * @generated from protobuf message payments.GetPaymentRequest
 */
export interface GetPaymentRequest {
    /**
     * @generated from protobuf field: string payment_id = 1
     */
    paymentId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetPaymentResponse
 */
export interface GetPaymentResponse {
    /**
     * @generated from protobuf field: payments.Payment payment = 1
     */
    payment?: Payment;
}
/**
 * @generated from protobuf message payments.ListMyPaymentsRequest
 */
export interface ListMyPaymentsRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: int32 offset = 2
     */
    offset: number;
    /**
     * @generated from protobuf field: int32 limit = 3
     */
    limit: number;
}
/**
 * @generated from protobuf message payments.ListMyPaymentsResponse
 */
export interface ListMyPaymentsResponse {
    /**
     * @generated from protobuf field: repeated payments.Payment payments = 1
     */
    payments: Payment[];
    /**
     * @generated from protobuf field: int32 offset = 2
     */
    offset: number;
    /**
     * @generated from protobuf field: int32 limit = 3
     */
    limit: number;
}
/**
 * @generated from protobuf message payments.CheckPaymentStatusRequest
 */
export interface CheckPaymentStatusRequest {
    /**
     * @generated from protobuf field: string payment_id = 1
     */
    paymentId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.CheckPaymentStatusResponse
 */
export interface CheckPaymentStatusResponse {
    /**
     * @generated from protobuf field: string payment_id = 1
     */
    paymentId: string;
    /**
     * @generated from protobuf field: string status = 2
     */
    status: string;
    /**
     * @generated from protobuf field: int64 amount = 3
     */
    amount: string;
    /**
     * @generated from protobuf field: string mpesa_receipt_number = 4
     */
    mpesaReceiptNumber: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp paid_at = 5
     */
    paidAt?: Timestamp;
}
/**
 * @generated from protobuf message payments.DownloadReceiptRequest
 */
export interface DownloadReceiptRequest {
    /**
     * @generated from protobuf field: string payment_id = 1
     */
    paymentId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.DownloadReceiptResponse
 */
export interface DownloadReceiptResponse {
    /**
     * @generated from protobuf field: bytes pdf_data = 1
     */
    pdfData: Uint8Array;
    /**
     * @generated from protobuf field: string filename = 2
     */
    filename: string;
}
/**
 * @generated from protobuf message payments.EmailReceiptRequest
 */
export interface EmailReceiptRequest {
    /**
     * @generated from protobuf field: string payment_id = 1
     */
    paymentId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string email = 3
     */
    email: string;
}
/**
 * @generated from protobuf message payments.EmailReceiptResponse
 */
export interface EmailReceiptResponse {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
// ═══════════════════════════════════════════════════════════════════════════
// PRORATION MESSAGES
// ═══════════════════════════════════════════════════════════════════════════

/**
 * @generated from protobuf message payments.PreviewProrationRequest
 */
export interface PreviewProrationRequest {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string new_plan_id = 2
     */
    newPlanId: string;
    /**
     * @generated from protobuf field: string user_id = 3
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.PreviewProrationResponse
 */
export interface PreviewProrationResponse {
    /**
     * @generated from protobuf field: payments.PlanSummary old_plan = 1
     */
    oldPlan?: PlanSummary;
    /**
     * @generated from protobuf field: payments.PlanSummary new_plan = 2
     */
    newPlan?: PlanSummary;
    /**
     * @generated from protobuf field: payments.ProrationDetails proration = 3
     */
    proration?: ProrationDetails;
}
/**
 * @generated from protobuf message payments.ChangePlanRequest
 */
export interface ChangePlanRequest {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string new_plan_id = 2
     */
    newPlanId: string;
    /**
     * @generated from protobuf field: string user_id = 3
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.ChangePlanResponse
 */
export interface ChangePlanResponse {
    /**
     * @generated from protobuf field: payments.Subscription subscription = 1
     */
    subscription?: Subscription;
    /**
     * @generated from protobuf field: payments.ProrationCredit proration_credit = 2
     */
    prorationCredit?: ProrationCredit;
    /**
     * @generated from protobuf field: payments.Payment payment = 3
     */
    payment?: Payment;
    /**
     * @generated from protobuf field: string message = 4
     */
    message: string;
}
/**
 * @generated from protobuf message payments.GetProrationHistoryRequest
 */
export interface GetProrationHistoryRequest {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetProrationHistoryResponse
 */
export interface GetProrationHistoryResponse {
    /**
     * @generated from protobuf field: repeated payments.ProrationCredit proration_credits = 1
     */
    prorationCredits: ProrationCredit[];
}
/**
 * @generated from protobuf message payments.GetCreditBalanceRequest
 */
export interface GetCreditBalanceRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetCreditBalanceResponse
 */
export interface GetCreditBalanceResponse {
    /**
     * @generated from protobuf field: int64 credit_balance = 1
     */
    creditBalance: string;
    /**
     * @generated from protobuf field: string formatted = 2
     */
    formatted: string;
}
/**
 * @generated from protobuf message payments.PlanSummary
 */
export interface PlanSummary {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: int64 price = 3
     */
    price: string;
}
/**
 * @generated from protobuf message payments.ProrationDetails
 */
export interface ProrationDetails {
    /**
     * @generated from protobuf field: int64 unused_credit = 1
     */
    unusedCredit: string;
    /**
     * @generated from protobuf field: int64 prorated_charge = 2
     */
    proratedCharge: string;
    /**
     * @generated from protobuf field: int64 net_amount = 3
     */
    netAmount: string;
    /**
     * @generated from protobuf field: int32 days_used = 4
     */
    daysUsed: number;
    /**
     * @generated from protobuf field: int32 days_remaining = 5
     */
    daysRemaining: number;
    /**
     * @generated from protobuf field: int32 total_days = 6
     */
    totalDays: number;
    /**
     * @generated from protobuf field: string description = 7
     */
    description: string;
}
/**
 * @generated from protobuf message payments.ProrationCredit
 */
export interface ProrationCredit {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string old_plan_id = 2
     */
    oldPlanId: string;
    /**
     * @generated from protobuf field: string new_plan_id = 3
     */
    newPlanId: string;
    /**
     * @generated from protobuf field: string old_plan_name = 4
     */
    oldPlanName: string;
    /**
     * @generated from protobuf field: string new_plan_name = 5
     */
    newPlanName: string;
    /**
     * @generated from protobuf field: int64 unused_credit = 6
     */
    unusedCredit: string;
    /**
     * @generated from protobuf field: int64 prorated_charge = 7
     */
    proratedCharge: string;
    /**
     * @generated from protobuf field: int64 net_amount = 8
     */
    netAmount: string;
    /**
     * @generated from protobuf field: int32 days_used = 9
     */
    daysUsed: number;
    /**
     * @generated from protobuf field: int32 days_remaining = 10
     */
    daysRemaining: number;
    /**
     * @generated from protobuf field: string status = 11
     */
    status: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp change_date = 12
     */
    changeDate?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp applied_at = 13
     */
    appliedAt?: Timestamp;
}
// ═══════════════════════════════════════════════════════════════════════════
// FRAUD PREVENTION ADMIN MESSAGES
// ═══════════════════════════════════════════════════════════════════════════

/**
 * @generated from protobuf message payments.GetFraudStatsRequest
 */
export interface GetFraudStatsRequest {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start_date = 1
     */
    startDate?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end_date = 2
     */
    endDate?: Timestamp;
}
/**
 * @generated from protobuf message payments.GetFraudStatsResponse
 */
export interface GetFraudStatsResponse {
    /**
     * @generated from protobuf field: int64 total_payments = 1
     */
    totalPayments: string;
    /**
     * @generated from protobuf field: int64 flagged_payments = 2
     */
    flaggedPayments: string;
    /**
     * @generated from protobuf field: int64 blocked_payments = 3
     */
    blockedPayments: string;
    /**
     * @generated from protobuf field: double fraud_rate = 4
     */
    fraudRate: number;
    /**
     * @generated from protobuf field: int64 blacklisted_phones = 5
     */
    blacklistedPhones: string;
    /**
     * @generated from protobuf field: int64 blacklisted_ips = 6
     */
    blacklistedIps: string;
    /**
     * @generated from protobuf field: int64 high_risk_users = 7
     */
    highRiskUsers: string;
    /**
     * @generated from protobuf field: map<string, int64> risk_level_distribution = 8
     */
    riskLevelDistribution: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, int64> fraud_reasons = 9
     */
    fraudReasons: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message payments.GetFlaggedUsersRequest
 */
export interface GetFlaggedUsersRequest {
    /**
     * @generated from protobuf field: string risk_level = 1
     */
    riskLevel: string;
    /**
     * @generated from protobuf field: int32 page = 2
     */
    page: number;
    /**
     * @generated from protobuf field: int32 page_size = 3
     */
    pageSize: number;
}
/**
 * @generated from protobuf message payments.GetFlaggedUsersResponse
 */
export interface GetFlaggedUsersResponse {
    /**
     * @generated from protobuf field: repeated payments.FlaggedUser users = 1
     */
    users: FlaggedUser[];
    /**
     * @generated from protobuf field: int32 total_count = 2
     */
    totalCount: number;
    /**
     * @generated from protobuf field: int32 page = 3
     */
    page: number;
    /**
     * @generated from protobuf field: int32 page_size = 4
     */
    pageSize: number;
}
/**
 * @generated from protobuf message payments.FlaggedUser
 */
export interface FlaggedUser {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string phone_number = 2
     */
    phoneNumber: string;
    /**
     * @generated from protobuf field: string risk_level = 3
     */
    riskLevel: string;
    /**
     * @generated from protobuf field: int32 risk_score = 4
     */
    riskScore: number;
    /**
     * @generated from protobuf field: repeated string fraud_indicators = 5
     */
    fraudIndicators: string[];
    /**
     * @generated from protobuf field: int64 payment_attempts_24h = 6
     */
    paymentAttempts24H: string;
    /**
     * @generated from protobuf field: int64 failed_payments = 7
     */
    failedPayments: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_flagged_at = 8
     */
    lastFlaggedAt?: Timestamp;
    /**
     * @generated from protobuf field: bool is_blacklisted = 9
     */
    isBlacklisted: boolean;
}
/**
 * @generated from protobuf message payments.GetBlacklistedPhonesRequest
 */
export interface GetBlacklistedPhonesRequest {
    /**
     * @generated from protobuf field: int32 page = 1
     */
    page: number;
    /**
     * @generated from protobuf field: int32 page_size = 2
     */
    pageSize: number;
}
/**
 * @generated from protobuf message payments.GetBlacklistedPhonesResponse
 */
export interface GetBlacklistedPhonesResponse {
    /**
     * @generated from protobuf field: repeated payments.BlacklistedPhone phones = 1
     */
    phones: BlacklistedPhone[];
    /**
     * @generated from protobuf field: int32 total_count = 2
     */
    totalCount: number;
    /**
     * @generated from protobuf field: int32 page = 3
     */
    page: number;
    /**
     * @generated from protobuf field: int32 page_size = 4
     */
    pageSize: number;
}
/**
 * @generated from protobuf message payments.BlacklistedPhone
 */
export interface BlacklistedPhone {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string phone_number = 2
     */
    phoneNumber: string;
    /**
     * @generated from protobuf field: string reason = 3
     */
    reason: string;
    /**
     * @generated from protobuf field: string added_by = 4
     */
    addedBy: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp blacklisted_at = 5
     */
    blacklistedAt?: Timestamp;
    /**
     * @generated from protobuf field: int64 blocked_attempts = 6
     */
    blockedAttempts: string;
}
/**
 * @generated from protobuf message payments.GetBlacklistedIPsRequest
 */
export interface GetBlacklistedIPsRequest {
    /**
     * @generated from protobuf field: int32 page = 1
     */
    page: number;
    /**
     * @generated from protobuf field: int32 page_size = 2
     */
    pageSize: number;
}
/**
 * @generated from protobuf message payments.GetBlacklistedIPsResponse
 */
export interface GetBlacklistedIPsResponse {
    /**
     * @generated from protobuf field: repeated payments.BlacklistedIP ips = 1
     */
    ips: BlacklistedIP[];
    /**
     * @generated from protobuf field: int32 total_count = 2
     */
    totalCount: number;
    /**
     * @generated from protobuf field: int32 page = 3
     */
    page: number;
    /**
     * @generated from protobuf field: int32 page_size = 4
     */
    pageSize: number;
}
/**
 * @generated from protobuf message payments.BlacklistedIP
 */
export interface BlacklistedIP {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string ip_address = 2
     */
    ipAddress: string;
    /**
     * @generated from protobuf field: string reason = 3
     */
    reason: string;
    /**
     * @generated from protobuf field: string added_by = 4
     */
    addedBy: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp blacklisted_at = 5
     */
    blacklistedAt?: Timestamp;
    /**
     * @generated from protobuf field: int64 blocked_attempts = 6
     */
    blockedAttempts: string;
}
/**
 * @generated from protobuf message payments.BlacklistPhoneRequest
 */
export interface BlacklistPhoneRequest {
    /**
     * @generated from protobuf field: string phone_number = 1
     */
    phoneNumber: string;
    /**
     * @generated from protobuf field: string reason = 2
     */
    reason: string;
    /**
     * @generated from protobuf field: string admin_user_id = 3
     */
    adminUserId: string;
}
/**
 * @generated from protobuf message payments.BlacklistPhoneResponse
 */
export interface BlacklistPhoneResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: payments.BlacklistedPhone phone = 3
     */
    phone?: BlacklistedPhone;
}
/**
 * @generated from protobuf message payments.BlacklistIPRequest
 */
export interface BlacklistIPRequest {
    /**
     * @generated from protobuf field: string ip_address = 1
     */
    ipAddress: string;
    /**
     * @generated from protobuf field: string reason = 2
     */
    reason: string;
    /**
     * @generated from protobuf field: string admin_user_id = 3
     */
    adminUserId: string;
}
/**
 * @generated from protobuf message payments.BlacklistIPResponse
 */
export interface BlacklistIPResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: payments.BlacklistedIP ip = 3
     */
    ip?: BlacklistedIP;
}
/**
 * @generated from protobuf message payments.RemovePhoneFromBlacklistRequest
 */
export interface RemovePhoneFromBlacklistRequest {
    /**
     * @generated from protobuf field: string phone_number = 1
     */
    phoneNumber: string;
    /**
     * @generated from protobuf field: string admin_user_id = 2
     */
    adminUserId: string;
    /**
     * @generated from protobuf field: string reason = 3
     */
    reason: string;
}
/**
 * @generated from protobuf message payments.RemovePhoneFromBlacklistResponse
 */
export interface RemovePhoneFromBlacklistResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message payments.RemoveIPFromBlacklistRequest
 */
export interface RemoveIPFromBlacklistRequest {
    /**
     * @generated from protobuf field: string ip_address = 1
     */
    ipAddress: string;
    /**
     * @generated from protobuf field: string admin_user_id = 2
     */
    adminUserId: string;
    /**
     * @generated from protobuf field: string reason = 3
     */
    reason: string;
}
/**
 * @generated from protobuf message payments.RemoveIPFromBlacklistResponse
 */
export interface RemoveIPFromBlacklistResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message payments.GetFraudRulesRequest
 */
export interface GetFraudRulesRequest {
}
/**
 * @generated from protobuf message payments.GetFraudRulesResponse
 */
export interface GetFraudRulesResponse {
    /**
     * @generated from protobuf field: repeated payments.FraudRule rules = 1
     */
    rules: FraudRule[];
}
/**
 * @generated from protobuf message payments.FraudRule
 */
export interface FraudRule {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: string rule_type = 4
     */
    ruleType: string;
    /**
     * @generated from protobuf field: map<string, string> parameters = 5
     */
    parameters: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: bool is_active = 6
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: int32 priority = 7
     */
    priority: number;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 8
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 9
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message payments.UpdateFraudRuleRequest
 */
export interface UpdateFraudRuleRequest {
    /**
     * @generated from protobuf field: string rule_id = 1
     */
    ruleId: string;
    /**
     * @generated from protobuf field: map<string, string> parameters = 2
     */
    parameters: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: bool is_active = 3
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: string admin_user_id = 4
     */
    adminUserId: string;
}
/**
 * @generated from protobuf message payments.UpdateFraudRuleResponse
 */
export interface UpdateFraudRuleResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: payments.FraudRule rule = 3
     */
    rule?: FraudRule;
}
// ── Pause/Resume Messages ──────────────────────────────────

/**
 * @generated from protobuf message payments.PauseSubscriptionRequest
 */
export interface PauseSubscriptionRequest {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string reason = 3
     */
    reason: string; // travel, financial, seasonal, not_using, other
    /**
     * @generated from protobuf field: int32 duration_days = 4
     */
    durationDays: number; // 7-90 days
}
/**
 * @generated from protobuf message payments.PauseSubscriptionResponse
 */
export interface PauseSubscriptionResponse {
    /**
     * @generated from protobuf field: payments.Subscription subscription = 1
     */
    subscription?: Subscription;
    /**
     * @generated from protobuf field: payments.PauseHistory pause_history = 2
     */
    pauseHistory?: PauseHistory;
    /**
     * @generated from protobuf field: string message = 3
     */
    message: string;
    /**
     * @generated from protobuf field: string resume_date = 4
     */
    resumeDate: string; // ISO 8601 format
    /**
     * @generated from protobuf field: string access_until = 5
     */
    accessUntil: string; // End of current billing period
}
/**
 * @generated from protobuf message payments.ResumeSubscriptionRequest
 */
export interface ResumeSubscriptionRequest {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.ResumeSubscriptionResponse
 */
export interface ResumeSubscriptionResponse {
    /**
     * @generated from protobuf field: payments.Subscription subscription = 1
     */
    subscription?: Subscription;
    /**
     * @generated from protobuf field: payments.PauseHistory pause_history = 2
     */
    pauseHistory?: PauseHistory;
    /**
     * @generated from protobuf field: string message = 3
     */
    message: string;
    /**
     * @generated from protobuf field: string next_billing_date = 4
     */
    nextBillingDate: string;
    /**
     * @generated from protobuf field: int64 next_billing_amount = 5
     */
    nextBillingAmount: string;
}
/**
 * @generated from protobuf message payments.GetPauseStatusRequest
 */
export interface GetPauseStatusRequest {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetPauseStatusResponse
 */
export interface GetPauseStatusResponse {
    /**
     * @generated from protobuf field: bool is_paused = 1
     */
    isPaused: boolean;
    /**
     * @generated from protobuf field: string paused_at = 2
     */
    pausedAt: string;
    /**
     * @generated from protobuf field: string resume_at = 3
     */
    resumeAt: string;
    /**
     * @generated from protobuf field: int32 days_remaining = 4
     */
    daysRemaining: number;
    /**
     * @generated from protobuf field: bool can_pause = 5
     */
    canPause: boolean;
    /**
     * @generated from protobuf field: string cannot_pause_reason = 6
     */
    cannotPauseReason: string;
    /**
     * @generated from protobuf field: repeated payments.PauseHistory history = 7
     */
    history: PauseHistory[];
}
/**
 * @generated from protobuf message payments.PauseHistory
 */
export interface PauseHistory {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string subscription_id = 2
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string user_id = 3
     */
    userId: string;
    /**
     * @generated from protobuf field: string paused_at = 4
     */
    pausedAt: string;
    /**
     * @generated from protobuf field: string resume_at = 5
     */
    resumeAt: string;
    /**
     * @generated from protobuf field: string resumed_at = 6
     */
    resumedAt: string;
    /**
     * @generated from protobuf field: string pause_reason = 7
     */
    pauseReason: string;
    /**
     * @generated from protobuf field: string status = 8
     */
    status: string; // active, resumed, cancelled
    /**
     * @generated from protobuf field: int32 duration_days = 9
     */
    durationDays: number;
    /**
     * @generated from protobuf field: int32 days_remaining = 10
     */
    daysRemaining: number;
}
// ── Self-Service Cancellation Messages ────────────────────────────────

/**
 * @generated from protobuf message payments.InitiateCancellationRequest
 */
export interface InitiateCancellationRequest {
    /**
     * @generated from protobuf field: string subscription_id = 1
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string reason_category = 3
     */
    reasonCategory: string; // price, features, not_using, found_alternative, etc.
    /**
     * @generated from protobuf field: string reason_text = 4
     */
    reasonText: string;
    /**
     * @generated from protobuf field: string feedback = 5
     */
    feedback: string;
    /**
     * @generated from protobuf field: string user_agent = 6
     */
    userAgent: string;
    /**
     * @generated from protobuf field: string ip_address = 7
     */
    ipAddress: string;
}
/**
 * @generated from protobuf message payments.InitiateCancellationResponse
 */
export interface InitiateCancellationResponse {
    /**
     * @generated from protobuf field: string cancellation_request_id = 1
     */
    cancellationRequestId: string;
    /**
     * @generated from protobuf field: string status = 2
     */
    status: string;
    /**
     * @generated from protobuf field: string effective_date = 3
     */
    effectiveDate: string; // ISO 8601 format
    /**
     * @generated from protobuf field: string access_until = 4
     */
    accessUntil: string; // ISO 8601 format
    /**
     * @generated from protobuf field: repeated payments.RetentionOffer retention_offers = 5
     */
    retentionOffers: RetentionOffer[];
    /**
     * @generated from protobuf field: string message = 6
     */
    message: string;
}
/**
 * @generated from protobuf message payments.RetentionOffer
 */
export interface RetentionOffer {
    /**
     * @generated from protobuf field: string type = 1
     */
    type: string; // pause, downgrade, discount
    /**
     * @generated from protobuf field: string title = 2
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: string current_price = 4
     */
    currentPrice: string;
    /**
     * @generated from protobuf field: string new_price = 5
     */
    newPrice: string;
    /**
     * @generated from protobuf field: int32 discount_percent = 6
     */
    discountPercent: number;
    /**
     * @generated from protobuf field: int32 duration_months = 7
     */
    durationMonths: number;
    /**
     * @generated from protobuf field: string action = 8
     */
    action: string;
    /**
     * @generated from protobuf field: double savings = 9
     */
    savings: number;
}
/**
 * @generated from protobuf message payments.AcceptRetentionOfferRequest
 */
export interface AcceptRetentionOfferRequest {
    /**
     * @generated from protobuf field: string cancellation_request_id = 1
     */
    cancellationRequestId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string offer_type = 3
     */
    offerType: string;
    /**
     * @generated from protobuf field: map<string, string> offer_details = 4
     */
    offerDetails: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message payments.AcceptRetentionOfferResponse
 */
export interface AcceptRetentionOfferResponse {
    /**
     * @generated from protobuf field: string status = 1
     */
    status: string;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: payments.Subscription subscription = 3
     */
    subscription?: Subscription;
}
/**
 * @generated from protobuf message payments.ConfirmCancellationRequest
 */
export interface ConfirmCancellationRequest {
    /**
     * @generated from protobuf field: string cancellation_request_id = 1
     */
    cancellationRequestId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.ConfirmCancellationResponse
 */
export interface ConfirmCancellationResponse {
    /**
     * @generated from protobuf field: string cancellation_request_id = 1
     */
    cancellationRequestId: string;
    /**
     * @generated from protobuf field: string status = 2
     */
    status: string;
    /**
     * @generated from protobuf field: string effective_date = 3
     */
    effectiveDate: string;
    /**
     * @generated from protobuf field: string access_until = 4
     */
    accessUntil: string;
    /**
     * @generated from protobuf field: bool can_undo = 5
     */
    canUndo: boolean;
    /**
     * @generated from protobuf field: string undo_deadline = 6
     */
    undoDeadline: string;
    /**
     * @generated from protobuf field: string message = 7
     */
    message: string;
}
/**
 * @generated from protobuf message payments.UndoCancellationRequest
 */
export interface UndoCancellationRequest {
    /**
     * @generated from protobuf field: string cancellation_request_id = 1
     */
    cancellationRequestId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.UndoCancellationResponse
 */
export interface UndoCancellationResponse {
    /**
     * @generated from protobuf field: string cancellation_request_id = 1
     */
    cancellationRequestId: string;
    /**
     * @generated from protobuf field: string status = 2
     */
    status: string;
    /**
     * @generated from protobuf field: string message = 3
     */
    message: string;
    /**
     * @generated from protobuf field: payments.Subscription subscription = 4
     */
    subscription?: Subscription;
}
/**
 * @generated from protobuf message payments.GetCancellationStatusRequest
 */
export interface GetCancellationStatusRequest {
    /**
     * @generated from protobuf field: string cancellation_request_id = 1
     */
    cancellationRequestId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetCancellationStatusResponse
 */
export interface GetCancellationStatusResponse {
    /**
     * @generated from protobuf field: payments.CancellationRequest cancellation_request = 1
     */
    cancellationRequest?: CancellationRequest;
    /**
     * @generated from protobuf field: bool can_undo = 2
     */
    canUndo: boolean;
    /**
     * @generated from protobuf field: int32 days_until_effective = 3
     */
    daysUntilEffective: number;
}
/**
 * @generated from protobuf message payments.CancellationRequest
 */
export interface CancellationRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string subscription_id = 2
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: string user_id = 3
     */
    userId: string;
    /**
     * @generated from protobuf field: string reason_category = 4
     */
    reasonCategory: string;
    /**
     * @generated from protobuf field: string reason_text = 5
     */
    reasonText: string;
    /**
     * @generated from protobuf field: string feedback = 6
     */
    feedback: string;
    /**
     * @generated from protobuf field: string requested_at = 7
     */
    requestedAt: string;
    /**
     * @generated from protobuf field: bool retention_offer_shown = 8
     */
    retentionOfferShown: boolean;
    /**
     * @generated from protobuf field: string retention_offer_type = 9
     */
    retentionOfferType: string;
    /**
     * @generated from protobuf field: bool retention_offer_accepted = 10
     */
    retentionOfferAccepted: boolean;
    /**
     * @generated from protobuf field: string status = 11
     */
    status: string;
    /**
     * @generated from protobuf field: string effective_date = 12
     */
    effectiveDate: string;
    /**
     * @generated from protobuf field: string completed_at = 13
     */
    completedAt: string;
}
// ═══════════════════════════════════════════════════════════════════════════
// ANALYTICS MESSAGES
// ═══════════════════════════════════════════════════════════════════════════

/**
 * @generated from protobuf message payments.GetAnalyticsRequest
 */
export interface GetAnalyticsRequest {
    /**
     * @generated from protobuf field: string start_date = 1
     */
    startDate: string; // ISO 8601 format
    /**
     * @generated from protobuf field: string end_date = 2
     */
    endDate: string; // ISO 8601 format
}
/**
 * @generated from protobuf message payments.GetAnalyticsResponse
 */
export interface GetAnalyticsResponse {
    /**
     * @generated from protobuf field: payments.AnalyticsMetrics metrics = 1
     */
    metrics?: AnalyticsMetrics;
}
/**
 * @generated from protobuf message payments.GetMRRMetricsRequest
 */
export interface GetMRRMetricsRequest {
    /**
     * @generated from protobuf field: string as_of_date = 1
     */
    asOfDate: string; // ISO 8601 format
}
/**
 * @generated from protobuf message payments.GetMRRMetricsResponse
 */
export interface GetMRRMetricsResponse {
    /**
     * @generated from protobuf field: int64 mrr = 1
     */
    mrr: string;
    /**
     * @generated from protobuf field: int64 arr = 2
     */
    arr: string;
    /**
     * @generated from protobuf field: double mrr_growth = 3
     */
    mrrGrowth: number;
    /**
     * @generated from protobuf field: map<string, int64> mrr_by_plan = 4
     */
    mrrByPlan: {
        [key: string]: string;
    }; // plan_id -> mrr
}
/**
 * @generated from protobuf message payments.GetChurnMetricsRequest
 */
export interface GetChurnMetricsRequest {
    /**
     * @generated from protobuf field: string month = 1
     */
    month: string; // YYYY-MM format
}
/**
 * @generated from protobuf message payments.GetChurnMetricsResponse
 */
export interface GetChurnMetricsResponse {
    /**
     * @generated from protobuf field: double churn_rate = 1
     */
    churnRate: number;
    /**
     * @generated from protobuf field: int64 churned_count = 2
     */
    churnedCount: string;
    /**
     * @generated from protobuf field: map<string, int64> churn_reasons = 3
     */
    churnReasons: {
        [key: string]: string;
    }; // reason -> count
}
/**
 * @generated from protobuf message payments.GetRevenueMetricsRequest
 */
export interface GetRevenueMetricsRequest {
    /**
     * @generated from protobuf field: string start_date = 1
     */
    startDate: string;
    /**
     * @generated from protobuf field: string end_date = 2
     */
    endDate: string;
}
/**
 * @generated from protobuf message payments.GetRevenueMetricsResponse
 */
export interface GetRevenueMetricsResponse {
    /**
     * @generated from protobuf field: int64 revenue = 1
     */
    revenue: string;
    /**
     * @generated from protobuf field: double revenue_growth = 2
     */
    revenueGrowth: number;
    /**
     * @generated from protobuf field: map<string, int64> revenue_by_plan = 3
     */
    revenueByPlan: {
        [key: string]: string;
    }; // plan_id -> revenue
}
/**
 * @generated from protobuf message payments.GetCohortAnalysisRequest
 */
export interface GetCohortAnalysisRequest {
    /**
     * @generated from protobuf field: string cohort_month = 1
     */
    cohortMonth: string; // YYYY-MM format
    /**
     * @generated from protobuf field: int32 months_to_track = 2
     */
    monthsToTrack: number;
}
/**
 * @generated from protobuf message payments.GetCohortAnalysisResponse
 */
export interface GetCohortAnalysisResponse {
    /**
     * @generated from protobuf field: payments.CohortAnalysis cohort = 1
     */
    cohort?: CohortAnalysis;
}
/**
 * @generated from protobuf message payments.ForecastRevenueRequest
 */
export interface ForecastRevenueRequest {
    /**
     * @generated from protobuf field: int32 months_ahead = 1
     */
    monthsAhead: number;
}
/**
 * @generated from protobuf message payments.ForecastRevenueResponse
 */
export interface ForecastRevenueResponse {
    /**
     * @generated from protobuf field: repeated payments.RevenueForecast forecasts = 1
     */
    forecasts: RevenueForecast[];
}
/**
 * @generated from protobuf message payments.GetUserAnalyticsRequest
 */
export interface GetUserAnalyticsRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetUserAnalyticsResponse
 */
export interface GetUserAnalyticsResponse {
    /**
     * @generated from protobuf field: payments.UserAnalytics analytics = 1
     */
    analytics?: UserAnalytics;
}
// Complex types

/**
 * @generated from protobuf message payments.AnalyticsMetrics
 */
export interface AnalyticsMetrics {
    /**
     * MRR Metrics
     *
     * @generated from protobuf field: int64 mrr = 1
     */
    mrr: string;
    /**
     * @generated from protobuf field: int64 arr = 2
     */
    arr: string;
    /**
     * @generated from protobuf field: double mrr_growth = 3
     */
    mrrGrowth: number;
    /**
     * @generated from protobuf field: map<string, int64> mrr_by_plan = 4
     */
    mrrByPlan: {
        [key: string]: string;
    };
    /**
     * Subscription Metrics
     *
     * @generated from protobuf field: int64 active_subscriptions = 5
     */
    activeSubscriptions: string;
    /**
     * @generated from protobuf field: int64 trial_subscriptions = 6
     */
    trialSubscriptions: string;
    /**
     * @generated from protobuf field: int64 paused_subscriptions = 7
     */
    pausedSubscriptions: string;
    /**
     * @generated from protobuf field: int64 cancelled_subscriptions = 8
     */
    cancelledSubscriptions: string;
    /**
     * Churn Metrics
     *
     * @generated from protobuf field: double churn_rate = 9
     */
    churnRate: number;
    /**
     * @generated from protobuf field: int64 churned_count = 10
     */
    churnedCount: string;
    /**
     * @generated from protobuf field: map<string, int64> churn_reasons = 11
     */
    churnReasons: {
        [key: string]: string;
    };
    /**
     * Revenue Metrics
     *
     * @generated from protobuf field: int64 revenue = 12
     */
    revenue: string;
    /**
     * @generated from protobuf field: double revenue_growth = 13
     */
    revenueGrowth: number;
    /**
     * @generated from protobuf field: map<string, int64> revenue_by_plan = 14
     */
    revenueByPlan: {
        [key: string]: string;
    };
    /**
     * Payment Metrics
     *
     * @generated from protobuf field: double payment_success_rate = 15
     */
    paymentSuccessRate: number;
    /**
     * @generated from protobuf field: int64 total_payments = 16
     */
    totalPayments: string;
    /**
     * @generated from protobuf field: int64 successful_payments = 17
     */
    successfulPayments: string;
    /**
     * @generated from protobuf field: int64 failed_payments = 18
     */
    failedPayments: string;
    /**
     * Customer Metrics
     *
     * @generated from protobuf field: int64 total_customers = 19
     */
    totalCustomers: string;
    /**
     * @generated from protobuf field: int64 new_customers = 20
     */
    newCustomers: string;
    /**
     * @generated from protobuf field: int64 average_lifetime_value = 21
     */
    averageLifetimeValue: string;
    /**
     * Period
     *
     * @generated from protobuf field: string period_start = 22
     */
    periodStart: string;
    /**
     * @generated from protobuf field: string period_end = 23
     */
    periodEnd: string;
}
/**
 * @generated from protobuf message payments.CohortAnalysis
 */
export interface CohortAnalysis {
    /**
     * @generated from protobuf field: string cohort_month = 1
     */
    cohortMonth: string;
    /**
     * @generated from protobuf field: int64 initial_size = 2
     */
    initialSize: string;
    /**
     * @generated from protobuf field: map<int32, double> retention = 3
     */
    retention: {
        [key: number]: number;
    }; // month -> retention %
    /**
     * @generated from protobuf field: int64 revenue = 4
     */
    revenue: string;
    /**
     * @generated from protobuf field: double average_revenue = 5
     */
    averageRevenue: number;
}
/**
 * @generated from protobuf message payments.RevenueForecast
 */
export interface RevenueForecast {
    /**
     * @generated from protobuf field: string month = 1
     */
    month: string;
    /**
     * @generated from protobuf field: int64 projected_revenue = 2
     */
    projectedRevenue: string;
    /**
     * @generated from protobuf field: int64 lower_bound = 3
     */
    lowerBound: string;
    /**
     * @generated from protobuf field: int64 upper_bound = 4
     */
    upperBound: string;
    /**
     * @generated from protobuf field: double confidence = 5
     */
    confidence: number;
}
/**
 * @generated from protobuf message payments.UserAnalytics
 */
export interface UserAnalytics {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: int64 total_spent = 2
     */
    totalSpent: string;
    /**
     * @generated from protobuf field: int64 lifetime_value = 3
     */
    lifetimeValue: string;
    /**
     * @generated from protobuf field: int32 subscription_count = 4
     */
    subscriptionCount: number;
    /**
     * @generated from protobuf field: int32 active_subscriptions = 5
     */
    activeSubscriptions: number;
    /**
     * @generated from protobuf field: int32 payment_count = 6
     */
    paymentCount: number;
    /**
     * @generated from protobuf field: int32 successful_payments = 7
     */
    successfulPayments: number;
    /**
     * @generated from protobuf field: int32 failed_payments = 8
     */
    failedPayments: number;
    /**
     * @generated from protobuf field: double payment_success_rate = 9
     */
    paymentSuccessRate: number;
    /**
     * @generated from protobuf field: string first_subscription = 10
     */
    firstSubscription: string;
    /**
     * @generated from protobuf field: int32 days_since_first = 11
     */
    daysSinceFirst: number;
    /**
     * @generated from protobuf field: int64 average_monthly_spend = 12
     */
    averageMonthlySpend: string;
}
// ═══════════════════════════════════════════════════════════════════════════
// PAYMENT METHOD MESSAGES
// ═══════════════════════════════════════════════════════════════════════════

/**
 * @generated from protobuf message payments.AddPaymentMethodRequest
 */
export interface AddPaymentMethodRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string type = 2
     */
    type: string; // mpesa, card, bank_transfer
    /**
     * @generated from protobuf field: string phone_number = 3
     */
    phoneNumber: string; // For M-Pesa
    /**
     * @generated from protobuf field: string card_last4 = 4
     */
    cardLast4: string; // For cards
    /**
     * @generated from protobuf field: string card_brand = 5
     */
    cardBrand: string; // visa, mastercard, etc.
    /**
     * @generated from protobuf field: int32 card_exp_month = 6
     */
    cardExpMonth: number;
    /**
     * @generated from protobuf field: int32 card_exp_year = 7
     */
    cardExpYear: number;
    /**
     * @generated from protobuf field: string nickname = 8
     */
    nickname: string;
    /**
     * @generated from protobuf field: bool is_default = 9
     */
    isDefault: boolean;
}
/**
 * @generated from protobuf message payments.AddPaymentMethodResponse
 */
export interface AddPaymentMethodResponse {
    /**
     * @generated from protobuf field: payments.PaymentMethod payment_method = 1
     */
    paymentMethod?: PaymentMethod;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message payments.GetPaymentMethodsRequest
 */
export interface GetPaymentMethodsRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetPaymentMethodsResponse
 */
export interface GetPaymentMethodsResponse {
    /**
     * @generated from protobuf field: repeated payments.PaymentMethod payment_methods = 1
     */
    paymentMethods: PaymentMethod[];
}
/**
 * @generated from protobuf message payments.GetDefaultPaymentMethodRequest
 */
export interface GetDefaultPaymentMethodRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.GetDefaultPaymentMethodResponse
 */
export interface GetDefaultPaymentMethodResponse {
    /**
     * @generated from protobuf field: payments.PaymentMethod payment_method = 1
     */
    paymentMethod?: PaymentMethod;
}
/**
 * @generated from protobuf message payments.SetDefaultPaymentMethodRequest
 */
export interface SetDefaultPaymentMethodRequest {
    /**
     * @generated from protobuf field: string method_id = 1
     */
    methodId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.SetDefaultPaymentMethodResponse
 */
export interface SetDefaultPaymentMethodResponse {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * @generated from protobuf message payments.RemovePaymentMethodRequest
 */
export interface RemovePaymentMethodRequest {
    /**
     * @generated from protobuf field: string method_id = 1
     */
    methodId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message payments.RemovePaymentMethodResponse
 */
export interface RemovePaymentMethodResponse {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * @generated from protobuf message payments.UpdatePaymentMethodNicknameRequest
 */
export interface UpdatePaymentMethodNicknameRequest {
    /**
     * @generated from protobuf field: string method_id = 1
     */
    methodId: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string nickname = 3
     */
    nickname: string;
}
/**
 * @generated from protobuf message payments.UpdatePaymentMethodNicknameResponse
 */
export interface UpdatePaymentMethodNicknameResponse {
    /**
     * @generated from protobuf field: payments.PaymentMethod payment_method = 1
     */
    paymentMethod?: PaymentMethod;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message payments.PaymentMethod
 */
export interface PaymentMethod {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string type = 2
     */
    type: string;
    /**
     * @generated from protobuf field: string phone_number = 3
     */
    phoneNumber: string; // Masked (e.g., ****1234)
    /**
     * @generated from protobuf field: string card_last4 = 4
     */
    cardLast4: string;
    /**
     * @generated from protobuf field: string card_brand = 5
     */
    cardBrand: string;
    /**
     * @generated from protobuf field: int32 card_exp_month = 6
     */
    cardExpMonth: number;
    /**
     * @generated from protobuf field: int32 card_exp_year = 7
     */
    cardExpYear: number;
    /**
     * @generated from protobuf field: string nickname = 8
     */
    nickname: string;
    /**
     * @generated from protobuf field: bool is_default = 9
     */
    isDefault: boolean;
    /**
     * @generated from protobuf field: bool is_expired = 10
     */
    isExpired: boolean;
    /**
     * @generated from protobuf field: string created_at = 11
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string last_used_at = 12
     */
    lastUsedAt: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class SubscriptionPlan$Type extends MessageType<SubscriptionPlan> {
    constructor() {
        super("payments.SubscriptionPlan", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "price_amount", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "billing_cycle", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "profile_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "trial_days", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "display_order", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "max_profiles", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "max_applications", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "max_hires", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 14, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<SubscriptionPlan>): SubscriptionPlan {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.priceAmount = "0";
        message.billingCycle = "";
        message.profileType = "";
        message.trialDays = 0;
        message.displayOrder = 0;
        message.isActive = false;
        message.maxProfiles = 0;
        message.maxApplications = 0;
        message.maxHires = 0;
        if (value !== undefined)
            reflectionMergePartial<SubscriptionPlan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscriptionPlan): SubscriptionPlan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* int64 price_amount */ 4:
                    message.priceAmount = reader.int64().toString();
                    break;
                case /* string billing_cycle */ 5:
                    message.billingCycle = reader.string();
                    break;
                case /* string profile_type */ 6:
                    message.profileType = reader.string();
                    break;
                case /* int32 trial_days */ 7:
                    message.trialDays = reader.int32();
                    break;
                case /* int32 display_order */ 8:
                    message.displayOrder = reader.int32();
                    break;
                case /* bool is_active */ 9:
                    message.isActive = reader.bool();
                    break;
                case /* int32 max_profiles */ 10:
                    message.maxProfiles = reader.int32();
                    break;
                case /* int32 max_applications */ 11:
                    message.maxApplications = reader.int32();
                    break;
                case /* int32 max_hires */ 12:
                    message.maxHires = reader.int32();
                    break;
                case /* google.protobuf.Timestamp created_at */ 13:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 14:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscriptionPlan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* int64 price_amount = 4; */
        if (message.priceAmount !== "0")
            writer.tag(4, WireType.Varint).int64(message.priceAmount);
        /* string billing_cycle = 5; */
        if (message.billingCycle !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.billingCycle);
        /* string profile_type = 6; */
        if (message.profileType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.profileType);
        /* int32 trial_days = 7; */
        if (message.trialDays !== 0)
            writer.tag(7, WireType.Varint).int32(message.trialDays);
        /* int32 display_order = 8; */
        if (message.displayOrder !== 0)
            writer.tag(8, WireType.Varint).int32(message.displayOrder);
        /* bool is_active = 9; */
        if (message.isActive !== false)
            writer.tag(9, WireType.Varint).bool(message.isActive);
        /* int32 max_profiles = 10; */
        if (message.maxProfiles !== 0)
            writer.tag(10, WireType.Varint).int32(message.maxProfiles);
        /* int32 max_applications = 11; */
        if (message.maxApplications !== 0)
            writer.tag(11, WireType.Varint).int32(message.maxApplications);
        /* int32 max_hires = 12; */
        if (message.maxHires !== 0)
            writer.tag(12, WireType.Varint).int32(message.maxHires);
        /* google.protobuf.Timestamp created_at = 13; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 14; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.SubscriptionPlan
 */
export const SubscriptionPlan = new SubscriptionPlan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Subscription$Type extends MessageType<Subscription> {
    constructor() {
        super("payments.Subscription", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "profile_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "profile_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "plan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "current_period_start", kind: "message", T: () => Timestamp },
            { no: 8, name: "current_period_end", kind: "message", T: () => Timestamp },
            { no: 9, name: "trial_end", kind: "message", T: () => Timestamp },
            { no: 10, name: "cancel_at_period_end", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "cancelled_at", kind: "message", T: () => Timestamp },
            { no: 12, name: "plan", kind: "message", T: () => SubscriptionPlan },
            { no: 13, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 14, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Subscription>): Subscription {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.userId = "";
        message.profileId = "";
        message.profileType = "";
        message.planId = "";
        message.status = "";
        message.cancelAtPeriodEnd = false;
        if (value !== undefined)
            reflectionMergePartial<Subscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subscription): Subscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                case /* string profile_id */ 3:
                    message.profileId = reader.string();
                    break;
                case /* string profile_type */ 4:
                    message.profileType = reader.string();
                    break;
                case /* string plan_id */ 5:
                    message.planId = reader.string();
                    break;
                case /* string status */ 6:
                    message.status = reader.string();
                    break;
                case /* google.protobuf.Timestamp current_period_start */ 7:
                    message.currentPeriodStart = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.currentPeriodStart);
                    break;
                case /* google.protobuf.Timestamp current_period_end */ 8:
                    message.currentPeriodEnd = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.currentPeriodEnd);
                    break;
                case /* google.protobuf.Timestamp trial_end */ 9:
                    message.trialEnd = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.trialEnd);
                    break;
                case /* bool cancel_at_period_end */ 10:
                    message.cancelAtPeriodEnd = reader.bool();
                    break;
                case /* google.protobuf.Timestamp cancelled_at */ 11:
                    message.cancelledAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.cancelledAt);
                    break;
                case /* payments.SubscriptionPlan plan */ 12:
                    message.plan = SubscriptionPlan.internalBinaryRead(reader, reader.uint32(), options, message.plan);
                    break;
                case /* google.protobuf.Timestamp created_at */ 13:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 14:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string profile_id = 3; */
        if (message.profileId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.profileId);
        /* string profile_type = 4; */
        if (message.profileType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.profileType);
        /* string plan_id = 5; */
        if (message.planId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.planId);
        /* string status = 6; */
        if (message.status !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.status);
        /* google.protobuf.Timestamp current_period_start = 7; */
        if (message.currentPeriodStart)
            Timestamp.internalBinaryWrite(message.currentPeriodStart, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp current_period_end = 8; */
        if (message.currentPeriodEnd)
            Timestamp.internalBinaryWrite(message.currentPeriodEnd, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp trial_end = 9; */
        if (message.trialEnd)
            Timestamp.internalBinaryWrite(message.trialEnd, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bool cancel_at_period_end = 10; */
        if (message.cancelAtPeriodEnd !== false)
            writer.tag(10, WireType.Varint).bool(message.cancelAtPeriodEnd);
        /* google.protobuf.Timestamp cancelled_at = 11; */
        if (message.cancelledAt)
            Timestamp.internalBinaryWrite(message.cancelledAt, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* payments.SubscriptionPlan plan = 12; */
        if (message.plan)
            SubscriptionPlan.internalBinaryWrite(message.plan, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 13; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 14; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.Subscription
 */
export const Subscription = new Subscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Payment$Type extends MessageType<Payment> {
    constructor() {
        super("payments.Payment", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "profile_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "profile_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "amount", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "payment_method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "phone_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "merchant_transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "fingo_transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "mpesa_receipt_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "failure_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "retry_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "paid_at", kind: "message", T: () => Timestamp },
            { no: 17, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 18, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Payment>): Payment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.userId = "";
        message.profileId = "";
        message.profileType = "";
        message.subscriptionId = "";
        message.amount = "0";
        message.currency = "";
        message.status = "";
        message.paymentMethod = "";
        message.phoneNumber = "";
        message.merchantTransactionId = "";
        message.fingoTransactionId = "";
        message.mpesaReceiptNumber = "";
        message.failureReason = "";
        message.retryCount = 0;
        if (value !== undefined)
            reflectionMergePartial<Payment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Payment): Payment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                case /* string profile_id */ 3:
                    message.profileId = reader.string();
                    break;
                case /* string profile_type */ 4:
                    message.profileType = reader.string();
                    break;
                case /* string subscription_id */ 5:
                    message.subscriptionId = reader.string();
                    break;
                case /* int64 amount */ 6:
                    message.amount = reader.int64().toString();
                    break;
                case /* string currency */ 7:
                    message.currency = reader.string();
                    break;
                case /* string status */ 8:
                    message.status = reader.string();
                    break;
                case /* string payment_method */ 9:
                    message.paymentMethod = reader.string();
                    break;
                case /* string phone_number */ 10:
                    message.phoneNumber = reader.string();
                    break;
                case /* string merchant_transaction_id */ 11:
                    message.merchantTransactionId = reader.string();
                    break;
                case /* string fingo_transaction_id */ 12:
                    message.fingoTransactionId = reader.string();
                    break;
                case /* string mpesa_receipt_number */ 13:
                    message.mpesaReceiptNumber = reader.string();
                    break;
                case /* string failure_reason */ 14:
                    message.failureReason = reader.string();
                    break;
                case /* int32 retry_count */ 15:
                    message.retryCount = reader.int32();
                    break;
                case /* google.protobuf.Timestamp paid_at */ 16:
                    message.paidAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.paidAt);
                    break;
                case /* google.protobuf.Timestamp created_at */ 17:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 18:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Payment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string profile_id = 3; */
        if (message.profileId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.profileId);
        /* string profile_type = 4; */
        if (message.profileType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.profileType);
        /* string subscription_id = 5; */
        if (message.subscriptionId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.subscriptionId);
        /* int64 amount = 6; */
        if (message.amount !== "0")
            writer.tag(6, WireType.Varint).int64(message.amount);
        /* string currency = 7; */
        if (message.currency !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.currency);
        /* string status = 8; */
        if (message.status !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.status);
        /* string payment_method = 9; */
        if (message.paymentMethod !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.paymentMethod);
        /* string phone_number = 10; */
        if (message.phoneNumber !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.phoneNumber);
        /* string merchant_transaction_id = 11; */
        if (message.merchantTransactionId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.merchantTransactionId);
        /* string fingo_transaction_id = 12; */
        if (message.fingoTransactionId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.fingoTransactionId);
        /* string mpesa_receipt_number = 13; */
        if (message.mpesaReceiptNumber !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.mpesaReceiptNumber);
        /* string failure_reason = 14; */
        if (message.failureReason !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.failureReason);
        /* int32 retry_count = 15; */
        if (message.retryCount !== 0)
            writer.tag(15, WireType.Varint).int32(message.retryCount);
        /* google.protobuf.Timestamp paid_at = 16; */
        if (message.paidAt)
            Timestamp.internalBinaryWrite(message.paidAt, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 17; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 18; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.Payment
 */
export const Payment = new Payment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlansRequest$Type extends MessageType<GetPlansRequest> {
    constructor() {
        super("payments.GetPlansRequest", []);
    }
    create(value?: PartialMessage<GetPlansRequest>): GetPlansRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPlansRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlansRequest): GetPlansRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlansRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPlansRequest
 */
export const GetPlansRequest = new GetPlansRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlansResponse$Type extends MessageType<GetPlansResponse> {
    constructor() {
        super("payments.GetPlansResponse", [
            { no: 1, name: "plans", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SubscriptionPlan }
        ]);
    }
    create(value?: PartialMessage<GetPlansResponse>): GetPlansResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.plans = [];
        if (value !== undefined)
            reflectionMergePartial<GetPlansResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlansResponse): GetPlansResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.SubscriptionPlan plans */ 1:
                    message.plans.push(SubscriptionPlan.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlansResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.SubscriptionPlan plans = 1; */
        for (let i = 0; i < message.plans.length; i++)
            SubscriptionPlan.internalBinaryWrite(message.plans[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPlansResponse
 */
export const GetPlansResponse = new GetPlansResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlanRequest$Type extends MessageType<GetPlanRequest> {
    constructor() {
        super("payments.GetPlanRequest", [
            { no: 1, name: "plan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPlanRequest>): GetPlanRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.planId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPlanRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlanRequest): GetPlanRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string plan_id */ 1:
                    message.planId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlanRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string plan_id = 1; */
        if (message.planId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.planId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPlanRequest
 */
export const GetPlanRequest = new GetPlanRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlanResponse$Type extends MessageType<GetPlanResponse> {
    constructor() {
        super("payments.GetPlanResponse", [
            { no: 1, name: "plan", kind: "message", T: () => SubscriptionPlan }
        ]);
    }
    create(value?: PartialMessage<GetPlanResponse>): GetPlanResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPlanResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlanResponse): GetPlanResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.SubscriptionPlan plan */ 1:
                    message.plan = SubscriptionPlan.internalBinaryRead(reader, reader.uint32(), options, message.plan);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlanResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.SubscriptionPlan plan = 1; */
        if (message.plan)
            SubscriptionPlan.internalBinaryWrite(message.plan, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPlanResponse
 */
export const GetPlanResponse = new GetPlanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSubscriptionRequest$Type extends MessageType<CreateSubscriptionRequest> {
    constructor() {
        super("payments.CreateSubscriptionRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "plan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "profile_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "profile_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateSubscriptionRequest>): CreateSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.planId = "";
        message.profileId = "";
        message.profileType = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSubscriptionRequest): CreateSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string plan_id */ 2:
                    message.planId = reader.string();
                    break;
                case /* string profile_id */ 3:
                    message.profileId = reader.string();
                    break;
                case /* string profile_type */ 4:
                    message.profileType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string plan_id = 2; */
        if (message.planId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.planId);
        /* string profile_id = 3; */
        if (message.profileId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.profileId);
        /* string profile_type = 4; */
        if (message.profileType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.profileType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CreateSubscriptionRequest
 */
export const CreateSubscriptionRequest = new CreateSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSubscriptionResponse$Type extends MessageType<CreateSubscriptionResponse> {
    constructor() {
        super("payments.CreateSubscriptionResponse", [
            { no: 1, name: "subscription", kind: "message", T: () => Subscription }
        ]);
    }
    create(value?: PartialMessage<CreateSubscriptionResponse>): CreateSubscriptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateSubscriptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSubscriptionResponse): CreateSubscriptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.Subscription subscription */ 1:
                    message.subscription = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.Subscription subscription = 1; */
        if (message.subscription)
            Subscription.internalBinaryWrite(message.subscription, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CreateSubscriptionResponse
 */
export const CreateSubscriptionResponse = new CreateSubscriptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubscriptionRequest$Type extends MessageType<GetSubscriptionRequest> {
    constructor() {
        super("payments.GetSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSubscriptionRequest>): GetSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubscriptionRequest): GetSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetSubscriptionRequest
 */
export const GetSubscriptionRequest = new GetSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubscriptionResponse$Type extends MessageType<GetSubscriptionResponse> {
    constructor() {
        super("payments.GetSubscriptionResponse", [
            { no: 1, name: "subscription", kind: "message", T: () => Subscription }
        ]);
    }
    create(value?: PartialMessage<GetSubscriptionResponse>): GetSubscriptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSubscriptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubscriptionResponse): GetSubscriptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.Subscription subscription */ 1:
                    message.subscription = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.Subscription subscription = 1; */
        if (message.subscription)
            Subscription.internalBinaryWrite(message.subscription, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetSubscriptionResponse
 */
export const GetSubscriptionResponse = new GetSubscriptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMySubscriptionRequest$Type extends MessageType<GetMySubscriptionRequest> {
    constructor() {
        super("payments.GetMySubscriptionRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMySubscriptionRequest>): GetMySubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetMySubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMySubscriptionRequest): GetMySubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMySubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetMySubscriptionRequest
 */
export const GetMySubscriptionRequest = new GetMySubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMySubscriptionResponse$Type extends MessageType<GetMySubscriptionResponse> {
    constructor() {
        super("payments.GetMySubscriptionResponse", [
            { no: 1, name: "subscription", kind: "message", T: () => Subscription }
        ]);
    }
    create(value?: PartialMessage<GetMySubscriptionResponse>): GetMySubscriptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMySubscriptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMySubscriptionResponse): GetMySubscriptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.Subscription subscription */ 1:
                    message.subscription = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMySubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.Subscription subscription = 1; */
        if (message.subscription)
            Subscription.internalBinaryWrite(message.subscription, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetMySubscriptionResponse
 */
export const GetMySubscriptionResponse = new GetMySubscriptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMySubscriptionsRequest$Type extends MessageType<ListMySubscriptionsRequest> {
    constructor() {
        super("payments.ListMySubscriptionsRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListMySubscriptionsRequest>): ListMySubscriptionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<ListMySubscriptionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMySubscriptionsRequest): ListMySubscriptionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMySubscriptionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ListMySubscriptionsRequest
 */
export const ListMySubscriptionsRequest = new ListMySubscriptionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMySubscriptionsResponse$Type extends MessageType<ListMySubscriptionsResponse> {
    constructor() {
        super("payments.ListMySubscriptionsResponse", [
            { no: 1, name: "subscriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Subscription }
        ]);
    }
    create(value?: PartialMessage<ListMySubscriptionsResponse>): ListMySubscriptionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptions = [];
        if (value !== undefined)
            reflectionMergePartial<ListMySubscriptionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMySubscriptionsResponse): ListMySubscriptionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.Subscription subscriptions */ 1:
                    message.subscriptions.push(Subscription.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMySubscriptionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.Subscription subscriptions = 1; */
        for (let i = 0; i < message.subscriptions.length; i++)
            Subscription.internalBinaryWrite(message.subscriptions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ListMySubscriptionsResponse
 */
export const ListMySubscriptionsResponse = new ListMySubscriptionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelSubscriptionRequest$Type extends MessageType<CancelSubscriptionRequest> {
    constructor() {
        super("payments.CancelSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelSubscriptionRequest>): CancelSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<CancelSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelSubscriptionRequest): CancelSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CancelSubscriptionRequest
 */
export const CancelSubscriptionRequest = new CancelSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelSubscriptionResponse$Type extends MessageType<CancelSubscriptionResponse> {
    constructor() {
        super("payments.CancelSubscriptionResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelSubscriptionResponse>): CancelSubscriptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<CancelSubscriptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelSubscriptionResponse): CancelSubscriptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelSubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CancelSubscriptionResponse
 */
export const CancelSubscriptionResponse = new CancelSubscriptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckSubscriptionAccessRequest$Type extends MessageType<CheckSubscriptionAccessRequest> {
    constructor() {
        super("payments.CheckSubscriptionAccessRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckSubscriptionAccessRequest>): CheckSubscriptionAccessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<CheckSubscriptionAccessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckSubscriptionAccessRequest): CheckSubscriptionAccessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckSubscriptionAccessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CheckSubscriptionAccessRequest
 */
export const CheckSubscriptionAccessRequest = new CheckSubscriptionAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckSubscriptionAccessResponse$Type extends MessageType<CheckSubscriptionAccessResponse> {
    constructor() {
        super("payments.CheckSubscriptionAccessResponse", [
            { no: 1, name: "has_access", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expires_at", kind: "message", T: () => Timestamp },
            { no: 5, name: "is_trial", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_early_adopter", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "days_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckSubscriptionAccessResponse>): CheckSubscriptionAccessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hasAccess = false;
        message.status = "";
        message.subscriptionId = "";
        message.isTrial = false;
        message.isEarlyAdopter = false;
        message.daysRemaining = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<CheckSubscriptionAccessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckSubscriptionAccessResponse): CheckSubscriptionAccessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool has_access */ 1:
                    message.hasAccess = reader.bool();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* string subscription_id */ 3:
                    message.subscriptionId = reader.string();
                    break;
                case /* google.protobuf.Timestamp expires_at */ 4:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                case /* bool is_trial */ 5:
                    message.isTrial = reader.bool();
                    break;
                case /* bool is_early_adopter */ 6:
                    message.isEarlyAdopter = reader.bool();
                    break;
                case /* int32 days_remaining */ 7:
                    message.daysRemaining = reader.int32();
                    break;
                case /* string message */ 8:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckSubscriptionAccessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool has_access = 1; */
        if (message.hasAccess !== false)
            writer.tag(1, WireType.Varint).bool(message.hasAccess);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* string subscription_id = 3; */
        if (message.subscriptionId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subscriptionId);
        /* google.protobuf.Timestamp expires_at = 4; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool is_trial = 5; */
        if (message.isTrial !== false)
            writer.tag(5, WireType.Varint).bool(message.isTrial);
        /* bool is_early_adopter = 6; */
        if (message.isEarlyAdopter !== false)
            writer.tag(6, WireType.Varint).bool(message.isEarlyAdopter);
        /* int32 days_remaining = 7; */
        if (message.daysRemaining !== 0)
            writer.tag(7, WireType.Varint).int32(message.daysRemaining);
        /* string message = 8; */
        if (message.message !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CheckSubscriptionAccessResponse
 */
export const CheckSubscriptionAccessResponse = new CheckSubscriptionAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSubscriptionCheckoutRequest$Type extends MessageType<CreateSubscriptionCheckoutRequest> {
    constructor() {
        super("payments.CreateSubscriptionCheckoutRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "plan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "phone_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "profile_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "profile_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateSubscriptionCheckoutRequest>): CreateSubscriptionCheckoutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.planId = "";
        message.phoneNumber = "";
        message.profileId = "";
        message.profileType = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSubscriptionCheckoutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSubscriptionCheckoutRequest): CreateSubscriptionCheckoutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string plan_id */ 2:
                    message.planId = reader.string();
                    break;
                case /* string phone_number */ 3:
                    message.phoneNumber = reader.string();
                    break;
                case /* string profile_id */ 4:
                    message.profileId = reader.string();
                    break;
                case /* string profile_type */ 5:
                    message.profileType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSubscriptionCheckoutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string plan_id = 2; */
        if (message.planId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.planId);
        /* string phone_number = 3; */
        if (message.phoneNumber !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.phoneNumber);
        /* string profile_id = 4; */
        if (message.profileId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.profileId);
        /* string profile_type = 5; */
        if (message.profileType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.profileType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CreateSubscriptionCheckoutRequest
 */
export const CreateSubscriptionCheckoutRequest = new CreateSubscriptionCheckoutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSubscriptionCheckoutResponse$Type extends MessageType<CreateSubscriptionCheckoutResponse> {
    constructor() {
        super("payments.CreateSubscriptionCheckoutResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "payment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "amount", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "plan", kind: "message", T: () => SubscriptionPlan }
        ]);
    }
    create(value?: PartialMessage<CreateSubscriptionCheckoutResponse>): CreateSubscriptionCheckoutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.paymentId = "";
        message.transactionId = "";
        message.status = "";
        message.message = "";
        message.amount = "0";
        if (value !== undefined)
            reflectionMergePartial<CreateSubscriptionCheckoutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSubscriptionCheckoutResponse): CreateSubscriptionCheckoutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string payment_id */ 2:
                    message.paymentId = reader.string();
                    break;
                case /* string transaction_id */ 3:
                    message.transactionId = reader.string();
                    break;
                case /* string status */ 4:
                    message.status = reader.string();
                    break;
                case /* string message */ 5:
                    message.message = reader.string();
                    break;
                case /* int64 amount */ 6:
                    message.amount = reader.int64().toString();
                    break;
                case /* payments.SubscriptionPlan plan */ 7:
                    message.plan = SubscriptionPlan.internalBinaryRead(reader, reader.uint32(), options, message.plan);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSubscriptionCheckoutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string payment_id = 2; */
        if (message.paymentId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paymentId);
        /* string transaction_id = 3; */
        if (message.transactionId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.transactionId);
        /* string status = 4; */
        if (message.status !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.status);
        /* string message = 5; */
        if (message.message !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.message);
        /* int64 amount = 6; */
        if (message.amount !== "0")
            writer.tag(6, WireType.Varint).int64(message.amount);
        /* payments.SubscriptionPlan plan = 7; */
        if (message.plan)
            SubscriptionPlan.internalBinaryWrite(message.plan, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CreateSubscriptionCheckoutResponse
 */
export const CreateSubscriptionCheckoutResponse = new CreateSubscriptionCheckoutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitiatePaymentRequest$Type extends MessageType<InitiatePaymentRequest> {
    constructor() {
        super("payments.InitiatePaymentRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "phone_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amount", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<InitiatePaymentRequest>): InitiatePaymentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.subscriptionId = "";
        message.phoneNumber = "";
        message.amount = "0";
        if (value !== undefined)
            reflectionMergePartial<InitiatePaymentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitiatePaymentRequest): InitiatePaymentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string subscription_id */ 2:
                    message.subscriptionId = reader.string();
                    break;
                case /* string phone_number */ 3:
                    message.phoneNumber = reader.string();
                    break;
                case /* int64 amount */ 4:
                    message.amount = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitiatePaymentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string subscription_id = 2; */
        if (message.subscriptionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subscriptionId);
        /* string phone_number = 3; */
        if (message.phoneNumber !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.phoneNumber);
        /* int64 amount = 4; */
        if (message.amount !== "0")
            writer.tag(4, WireType.Varint).int64(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.InitiatePaymentRequest
 */
export const InitiatePaymentRequest = new InitiatePaymentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitiatePaymentResponse$Type extends MessageType<InitiatePaymentResponse> {
    constructor() {
        super("payments.InitiatePaymentResponse", [
            { no: 1, name: "payment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InitiatePaymentResponse>): InitiatePaymentResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paymentId = "";
        message.transactionId = "";
        message.status = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<InitiatePaymentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitiatePaymentResponse): InitiatePaymentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string payment_id */ 1:
                    message.paymentId = reader.string();
                    break;
                case /* string transaction_id */ 2:
                    message.transactionId = reader.string();
                    break;
                case /* string status */ 3:
                    message.status = reader.string();
                    break;
                case /* string message */ 4:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitiatePaymentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string payment_id = 1; */
        if (message.paymentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paymentId);
        /* string transaction_id = 2; */
        if (message.transactionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.transactionId);
        /* string status = 3; */
        if (message.status !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        /* string message = 4; */
        if (message.message !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.InitiatePaymentResponse
 */
export const InitiatePaymentResponse = new InitiatePaymentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaymentRequest$Type extends MessageType<GetPaymentRequest> {
    constructor() {
        super("payments.GetPaymentRequest", [
            { no: 1, name: "payment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPaymentRequest>): GetPaymentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paymentId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaymentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaymentRequest): GetPaymentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string payment_id */ 1:
                    message.paymentId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaymentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string payment_id = 1; */
        if (message.paymentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paymentId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPaymentRequest
 */
export const GetPaymentRequest = new GetPaymentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaymentResponse$Type extends MessageType<GetPaymentResponse> {
    constructor() {
        super("payments.GetPaymentResponse", [
            { no: 1, name: "payment", kind: "message", T: () => Payment }
        ]);
    }
    create(value?: PartialMessage<GetPaymentResponse>): GetPaymentResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPaymentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaymentResponse): GetPaymentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.Payment payment */ 1:
                    message.payment = Payment.internalBinaryRead(reader, reader.uint32(), options, message.payment);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaymentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.Payment payment = 1; */
        if (message.payment)
            Payment.internalBinaryWrite(message.payment, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPaymentResponse
 */
export const GetPaymentResponse = new GetPaymentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMyPaymentsRequest$Type extends MessageType<ListMyPaymentsRequest> {
    constructor() {
        super("payments.ListMyPaymentsRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "offset", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListMyPaymentsRequest>): ListMyPaymentsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.offset = 0;
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<ListMyPaymentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMyPaymentsRequest): ListMyPaymentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* int32 offset */ 2:
                    message.offset = reader.int32();
                    break;
                case /* int32 limit */ 3:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMyPaymentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* int32 offset = 2; */
        if (message.offset !== 0)
            writer.tag(2, WireType.Varint).int32(message.offset);
        /* int32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ListMyPaymentsRequest
 */
export const ListMyPaymentsRequest = new ListMyPaymentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMyPaymentsResponse$Type extends MessageType<ListMyPaymentsResponse> {
    constructor() {
        super("payments.ListMyPaymentsResponse", [
            { no: 1, name: "payments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Payment },
            { no: 2, name: "offset", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListMyPaymentsResponse>): ListMyPaymentsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payments = [];
        message.offset = 0;
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<ListMyPaymentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMyPaymentsResponse): ListMyPaymentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.Payment payments */ 1:
                    message.payments.push(Payment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 offset */ 2:
                    message.offset = reader.int32();
                    break;
                case /* int32 limit */ 3:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMyPaymentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.Payment payments = 1; */
        for (let i = 0; i < message.payments.length; i++)
            Payment.internalBinaryWrite(message.payments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 offset = 2; */
        if (message.offset !== 0)
            writer.tag(2, WireType.Varint).int32(message.offset);
        /* int32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ListMyPaymentsResponse
 */
export const ListMyPaymentsResponse = new ListMyPaymentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPaymentStatusRequest$Type extends MessageType<CheckPaymentStatusRequest> {
    constructor() {
        super("payments.CheckPaymentStatusRequest", [
            { no: 1, name: "payment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckPaymentStatusRequest>): CheckPaymentStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paymentId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<CheckPaymentStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckPaymentStatusRequest): CheckPaymentStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string payment_id */ 1:
                    message.paymentId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckPaymentStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string payment_id = 1; */
        if (message.paymentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paymentId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CheckPaymentStatusRequest
 */
export const CheckPaymentStatusRequest = new CheckPaymentStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPaymentStatusResponse$Type extends MessageType<CheckPaymentStatusResponse> {
    constructor() {
        super("payments.CheckPaymentStatusResponse", [
            { no: 1, name: "payment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "mpesa_receipt_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "paid_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<CheckPaymentStatusResponse>): CheckPaymentStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paymentId = "";
        message.status = "";
        message.amount = "0";
        message.mpesaReceiptNumber = "";
        if (value !== undefined)
            reflectionMergePartial<CheckPaymentStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckPaymentStatusResponse): CheckPaymentStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string payment_id */ 1:
                    message.paymentId = reader.string();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* int64 amount */ 3:
                    message.amount = reader.int64().toString();
                    break;
                case /* string mpesa_receipt_number */ 4:
                    message.mpesaReceiptNumber = reader.string();
                    break;
                case /* google.protobuf.Timestamp paid_at */ 5:
                    message.paidAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.paidAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckPaymentStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string payment_id = 1; */
        if (message.paymentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paymentId);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* int64 amount = 3; */
        if (message.amount !== "0")
            writer.tag(3, WireType.Varint).int64(message.amount);
        /* string mpesa_receipt_number = 4; */
        if (message.mpesaReceiptNumber !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.mpesaReceiptNumber);
        /* google.protobuf.Timestamp paid_at = 5; */
        if (message.paidAt)
            Timestamp.internalBinaryWrite(message.paidAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CheckPaymentStatusResponse
 */
export const CheckPaymentStatusResponse = new CheckPaymentStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadReceiptRequest$Type extends MessageType<DownloadReceiptRequest> {
    constructor() {
        super("payments.DownloadReceiptRequest", [
            { no: 1, name: "payment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DownloadReceiptRequest>): DownloadReceiptRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paymentId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<DownloadReceiptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadReceiptRequest): DownloadReceiptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string payment_id */ 1:
                    message.paymentId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadReceiptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string payment_id = 1; */
        if (message.paymentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paymentId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.DownloadReceiptRequest
 */
export const DownloadReceiptRequest = new DownloadReceiptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadReceiptResponse$Type extends MessageType<DownloadReceiptResponse> {
    constructor() {
        super("payments.DownloadReceiptResponse", [
            { no: 1, name: "pdf_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "filename", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DownloadReceiptResponse>): DownloadReceiptResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfData = new Uint8Array(0);
        message.filename = "";
        if (value !== undefined)
            reflectionMergePartial<DownloadReceiptResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadReceiptResponse): DownloadReceiptResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes pdf_data */ 1:
                    message.pdfData = reader.bytes();
                    break;
                case /* string filename */ 2:
                    message.filename = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadReceiptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes pdf_data = 1; */
        if (message.pdfData.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.pdfData);
        /* string filename = 2; */
        if (message.filename !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.filename);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.DownloadReceiptResponse
 */
export const DownloadReceiptResponse = new DownloadReceiptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmailReceiptRequest$Type extends MessageType<EmailReceiptRequest> {
    constructor() {
        super("payments.EmailReceiptRequest", [
            { no: 1, name: "payment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EmailReceiptRequest>): EmailReceiptRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paymentId = "";
        message.userId = "";
        message.email = "";
        if (value !== undefined)
            reflectionMergePartial<EmailReceiptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmailReceiptRequest): EmailReceiptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string payment_id */ 1:
                    message.paymentId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmailReceiptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string payment_id = 1; */
        if (message.paymentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paymentId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.EmailReceiptRequest
 */
export const EmailReceiptRequest = new EmailReceiptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmailReceiptResponse$Type extends MessageType<EmailReceiptResponse> {
    constructor() {
        super("payments.EmailReceiptResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EmailReceiptResponse>): EmailReceiptResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<EmailReceiptResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmailReceiptResponse): EmailReceiptResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmailReceiptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.EmailReceiptResponse
 */
export const EmailReceiptResponse = new EmailReceiptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreviewProrationRequest$Type extends MessageType<PreviewProrationRequest> {
    constructor() {
        super("payments.PreviewProrationRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "new_plan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PreviewProrationRequest>): PreviewProrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.newPlanId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<PreviewProrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PreviewProrationRequest): PreviewProrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string new_plan_id */ 2:
                    message.newPlanId = reader.string();
                    break;
                case /* string user_id */ 3:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PreviewProrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string new_plan_id = 2; */
        if (message.newPlanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newPlanId);
        /* string user_id = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.PreviewProrationRequest
 */
export const PreviewProrationRequest = new PreviewProrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreviewProrationResponse$Type extends MessageType<PreviewProrationResponse> {
    constructor() {
        super("payments.PreviewProrationResponse", [
            { no: 1, name: "old_plan", kind: "message", T: () => PlanSummary },
            { no: 2, name: "new_plan", kind: "message", T: () => PlanSummary },
            { no: 3, name: "proration", kind: "message", T: () => ProrationDetails }
        ]);
    }
    create(value?: PartialMessage<PreviewProrationResponse>): PreviewProrationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PreviewProrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PreviewProrationResponse): PreviewProrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.PlanSummary old_plan */ 1:
                    message.oldPlan = PlanSummary.internalBinaryRead(reader, reader.uint32(), options, message.oldPlan);
                    break;
                case /* payments.PlanSummary new_plan */ 2:
                    message.newPlan = PlanSummary.internalBinaryRead(reader, reader.uint32(), options, message.newPlan);
                    break;
                case /* payments.ProrationDetails proration */ 3:
                    message.proration = ProrationDetails.internalBinaryRead(reader, reader.uint32(), options, message.proration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PreviewProrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.PlanSummary old_plan = 1; */
        if (message.oldPlan)
            PlanSummary.internalBinaryWrite(message.oldPlan, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payments.PlanSummary new_plan = 2; */
        if (message.newPlan)
            PlanSummary.internalBinaryWrite(message.newPlan, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* payments.ProrationDetails proration = 3; */
        if (message.proration)
            ProrationDetails.internalBinaryWrite(message.proration, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.PreviewProrationResponse
 */
export const PreviewProrationResponse = new PreviewProrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePlanRequest$Type extends MessageType<ChangePlanRequest> {
    constructor() {
        super("payments.ChangePlanRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "new_plan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChangePlanRequest>): ChangePlanRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.newPlanId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<ChangePlanRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePlanRequest): ChangePlanRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string new_plan_id */ 2:
                    message.newPlanId = reader.string();
                    break;
                case /* string user_id */ 3:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePlanRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string new_plan_id = 2; */
        if (message.newPlanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newPlanId);
        /* string user_id = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ChangePlanRequest
 */
export const ChangePlanRequest = new ChangePlanRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePlanResponse$Type extends MessageType<ChangePlanResponse> {
    constructor() {
        super("payments.ChangePlanResponse", [
            { no: 1, name: "subscription", kind: "message", T: () => Subscription },
            { no: 2, name: "proration_credit", kind: "message", T: () => ProrationCredit },
            { no: 3, name: "payment", kind: "message", T: () => Payment },
            { no: 4, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChangePlanResponse>): ChangePlanResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ChangePlanResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePlanResponse): ChangePlanResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.Subscription subscription */ 1:
                    message.subscription = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                case /* payments.ProrationCredit proration_credit */ 2:
                    message.prorationCredit = ProrationCredit.internalBinaryRead(reader, reader.uint32(), options, message.prorationCredit);
                    break;
                case /* payments.Payment payment */ 3:
                    message.payment = Payment.internalBinaryRead(reader, reader.uint32(), options, message.payment);
                    break;
                case /* string message */ 4:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePlanResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.Subscription subscription = 1; */
        if (message.subscription)
            Subscription.internalBinaryWrite(message.subscription, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payments.ProrationCredit proration_credit = 2; */
        if (message.prorationCredit)
            ProrationCredit.internalBinaryWrite(message.prorationCredit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* payments.Payment payment = 3; */
        if (message.payment)
            Payment.internalBinaryWrite(message.payment, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string message = 4; */
        if (message.message !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ChangePlanResponse
 */
export const ChangePlanResponse = new ChangePlanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProrationHistoryRequest$Type extends MessageType<GetProrationHistoryRequest> {
    constructor() {
        super("payments.GetProrationHistoryRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetProrationHistoryRequest>): GetProrationHistoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetProrationHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProrationHistoryRequest): GetProrationHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProrationHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetProrationHistoryRequest
 */
export const GetProrationHistoryRequest = new GetProrationHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProrationHistoryResponse$Type extends MessageType<GetProrationHistoryResponse> {
    constructor() {
        super("payments.GetProrationHistoryResponse", [
            { no: 1, name: "proration_credits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProrationCredit }
        ]);
    }
    create(value?: PartialMessage<GetProrationHistoryResponse>): GetProrationHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prorationCredits = [];
        if (value !== undefined)
            reflectionMergePartial<GetProrationHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProrationHistoryResponse): GetProrationHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.ProrationCredit proration_credits */ 1:
                    message.prorationCredits.push(ProrationCredit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProrationHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.ProrationCredit proration_credits = 1; */
        for (let i = 0; i < message.prorationCredits.length; i++)
            ProrationCredit.internalBinaryWrite(message.prorationCredits[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetProrationHistoryResponse
 */
export const GetProrationHistoryResponse = new GetProrationHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCreditBalanceRequest$Type extends MessageType<GetCreditBalanceRequest> {
    constructor() {
        super("payments.GetCreditBalanceRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCreditBalanceRequest>): GetCreditBalanceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetCreditBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCreditBalanceRequest): GetCreditBalanceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCreditBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetCreditBalanceRequest
 */
export const GetCreditBalanceRequest = new GetCreditBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCreditBalanceResponse$Type extends MessageType<GetCreditBalanceResponse> {
    constructor() {
        super("payments.GetCreditBalanceResponse", [
            { no: 1, name: "credit_balance", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "formatted", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCreditBalanceResponse>): GetCreditBalanceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.creditBalance = "0";
        message.formatted = "";
        if (value !== undefined)
            reflectionMergePartial<GetCreditBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCreditBalanceResponse): GetCreditBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 credit_balance */ 1:
                    message.creditBalance = reader.int64().toString();
                    break;
                case /* string formatted */ 2:
                    message.formatted = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCreditBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 credit_balance = 1; */
        if (message.creditBalance !== "0")
            writer.tag(1, WireType.Varint).int64(message.creditBalance);
        /* string formatted = 2; */
        if (message.formatted !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.formatted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetCreditBalanceResponse
 */
export const GetCreditBalanceResponse = new GetCreditBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlanSummary$Type extends MessageType<PlanSummary> {
    constructor() {
        super("payments.PlanSummary", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<PlanSummary>): PlanSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.price = "0";
        if (value !== undefined)
            reflectionMergePartial<PlanSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlanSummary): PlanSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 price */ 3:
                    message.price = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlanSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 price = 3; */
        if (message.price !== "0")
            writer.tag(3, WireType.Varint).int64(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.PlanSummary
 */
export const PlanSummary = new PlanSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProrationDetails$Type extends MessageType<ProrationDetails> {
    constructor() {
        super("payments.ProrationDetails", [
            { no: 1, name: "unused_credit", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "prorated_charge", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "net_amount", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "days_used", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "days_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "total_days", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProrationDetails>): ProrationDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unusedCredit = "0";
        message.proratedCharge = "0";
        message.netAmount = "0";
        message.daysUsed = 0;
        message.daysRemaining = 0;
        message.totalDays = 0;
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<ProrationDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProrationDetails): ProrationDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 unused_credit */ 1:
                    message.unusedCredit = reader.int64().toString();
                    break;
                case /* int64 prorated_charge */ 2:
                    message.proratedCharge = reader.int64().toString();
                    break;
                case /* int64 net_amount */ 3:
                    message.netAmount = reader.int64().toString();
                    break;
                case /* int32 days_used */ 4:
                    message.daysUsed = reader.int32();
                    break;
                case /* int32 days_remaining */ 5:
                    message.daysRemaining = reader.int32();
                    break;
                case /* int32 total_days */ 6:
                    message.totalDays = reader.int32();
                    break;
                case /* string description */ 7:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProrationDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 unused_credit = 1; */
        if (message.unusedCredit !== "0")
            writer.tag(1, WireType.Varint).int64(message.unusedCredit);
        /* int64 prorated_charge = 2; */
        if (message.proratedCharge !== "0")
            writer.tag(2, WireType.Varint).int64(message.proratedCharge);
        /* int64 net_amount = 3; */
        if (message.netAmount !== "0")
            writer.tag(3, WireType.Varint).int64(message.netAmount);
        /* int32 days_used = 4; */
        if (message.daysUsed !== 0)
            writer.tag(4, WireType.Varint).int32(message.daysUsed);
        /* int32 days_remaining = 5; */
        if (message.daysRemaining !== 0)
            writer.tag(5, WireType.Varint).int32(message.daysRemaining);
        /* int32 total_days = 6; */
        if (message.totalDays !== 0)
            writer.tag(6, WireType.Varint).int32(message.totalDays);
        /* string description = 7; */
        if (message.description !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ProrationDetails
 */
export const ProrationDetails = new ProrationDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProrationCredit$Type extends MessageType<ProrationCredit> {
    constructor() {
        super("payments.ProrationCredit", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "old_plan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_plan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "old_plan_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "new_plan_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "unused_credit", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "prorated_charge", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "net_amount", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 9, name: "days_used", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "days_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "change_date", kind: "message", T: () => Timestamp },
            { no: 13, name: "applied_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ProrationCredit>): ProrationCredit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.oldPlanId = "";
        message.newPlanId = "";
        message.oldPlanName = "";
        message.newPlanName = "";
        message.unusedCredit = "0";
        message.proratedCharge = "0";
        message.netAmount = "0";
        message.daysUsed = 0;
        message.daysRemaining = 0;
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<ProrationCredit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProrationCredit): ProrationCredit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string old_plan_id */ 2:
                    message.oldPlanId = reader.string();
                    break;
                case /* string new_plan_id */ 3:
                    message.newPlanId = reader.string();
                    break;
                case /* string old_plan_name */ 4:
                    message.oldPlanName = reader.string();
                    break;
                case /* string new_plan_name */ 5:
                    message.newPlanName = reader.string();
                    break;
                case /* int64 unused_credit */ 6:
                    message.unusedCredit = reader.int64().toString();
                    break;
                case /* int64 prorated_charge */ 7:
                    message.proratedCharge = reader.int64().toString();
                    break;
                case /* int64 net_amount */ 8:
                    message.netAmount = reader.int64().toString();
                    break;
                case /* int32 days_used */ 9:
                    message.daysUsed = reader.int32();
                    break;
                case /* int32 days_remaining */ 10:
                    message.daysRemaining = reader.int32();
                    break;
                case /* string status */ 11:
                    message.status = reader.string();
                    break;
                case /* google.protobuf.Timestamp change_date */ 12:
                    message.changeDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.changeDate);
                    break;
                case /* google.protobuf.Timestamp applied_at */ 13:
                    message.appliedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.appliedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProrationCredit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string old_plan_id = 2; */
        if (message.oldPlanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oldPlanId);
        /* string new_plan_id = 3; */
        if (message.newPlanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newPlanId);
        /* string old_plan_name = 4; */
        if (message.oldPlanName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oldPlanName);
        /* string new_plan_name = 5; */
        if (message.newPlanName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.newPlanName);
        /* int64 unused_credit = 6; */
        if (message.unusedCredit !== "0")
            writer.tag(6, WireType.Varint).int64(message.unusedCredit);
        /* int64 prorated_charge = 7; */
        if (message.proratedCharge !== "0")
            writer.tag(7, WireType.Varint).int64(message.proratedCharge);
        /* int64 net_amount = 8; */
        if (message.netAmount !== "0")
            writer.tag(8, WireType.Varint).int64(message.netAmount);
        /* int32 days_used = 9; */
        if (message.daysUsed !== 0)
            writer.tag(9, WireType.Varint).int32(message.daysUsed);
        /* int32 days_remaining = 10; */
        if (message.daysRemaining !== 0)
            writer.tag(10, WireType.Varint).int32(message.daysRemaining);
        /* string status = 11; */
        if (message.status !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.status);
        /* google.protobuf.Timestamp change_date = 12; */
        if (message.changeDate)
            Timestamp.internalBinaryWrite(message.changeDate, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp applied_at = 13; */
        if (message.appliedAt)
            Timestamp.internalBinaryWrite(message.appliedAt, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ProrationCredit
 */
export const ProrationCredit = new ProrationCredit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFraudStatsRequest$Type extends MessageType<GetFraudStatsRequest> {
    constructor() {
        super("payments.GetFraudStatsRequest", [
            { no: 1, name: "start_date", kind: "message", T: () => Timestamp },
            { no: 2, name: "end_date", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<GetFraudStatsRequest>): GetFraudStatsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetFraudStatsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFraudStatsRequest): GetFraudStatsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start_date */ 1:
                    message.startDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startDate);
                    break;
                case /* google.protobuf.Timestamp end_date */ 2:
                    message.endDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.endDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFraudStatsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start_date = 1; */
        if (message.startDate)
            Timestamp.internalBinaryWrite(message.startDate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end_date = 2; */
        if (message.endDate)
            Timestamp.internalBinaryWrite(message.endDate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetFraudStatsRequest
 */
export const GetFraudStatsRequest = new GetFraudStatsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFraudStatsResponse$Type extends MessageType<GetFraudStatsResponse> {
    constructor() {
        super("payments.GetFraudStatsResponse", [
            { no: 1, name: "total_payments", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "flagged_payments", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "blocked_payments", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "fraud_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "blacklisted_phones", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "blacklisted_ips", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "high_risk_users", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "risk_level_distribution", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } },
            { no: 9, name: "fraud_reasons", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } }
        ]);
    }
    create(value?: PartialMessage<GetFraudStatsResponse>): GetFraudStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalPayments = "0";
        message.flaggedPayments = "0";
        message.blockedPayments = "0";
        message.fraudRate = 0;
        message.blacklistedPhones = "0";
        message.blacklistedIps = "0";
        message.highRiskUsers = "0";
        message.riskLevelDistribution = {};
        message.fraudReasons = {};
        if (value !== undefined)
            reflectionMergePartial<GetFraudStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFraudStatsResponse): GetFraudStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 total_payments */ 1:
                    message.totalPayments = reader.int64().toString();
                    break;
                case /* int64 flagged_payments */ 2:
                    message.flaggedPayments = reader.int64().toString();
                    break;
                case /* int64 blocked_payments */ 3:
                    message.blockedPayments = reader.int64().toString();
                    break;
                case /* double fraud_rate */ 4:
                    message.fraudRate = reader.double();
                    break;
                case /* int64 blacklisted_phones */ 5:
                    message.blacklistedPhones = reader.int64().toString();
                    break;
                case /* int64 blacklisted_ips */ 6:
                    message.blacklistedIps = reader.int64().toString();
                    break;
                case /* int64 high_risk_users */ 7:
                    message.highRiskUsers = reader.int64().toString();
                    break;
                case /* map<string, int64> risk_level_distribution */ 8:
                    this.binaryReadMap8(message.riskLevelDistribution, reader, options);
                    break;
                case /* map<string, int64> fraud_reasons */ 9:
                    this.binaryReadMap9(message.fraudReasons, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: GetFraudStatsResponse["riskLevelDistribution"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetFraudStatsResponse["riskLevelDistribution"] | undefined, val: GetFraudStatsResponse["riskLevelDistribution"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.GetFraudStatsResponse.risk_level_distribution");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    private binaryReadMap9(map: GetFraudStatsResponse["fraudReasons"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetFraudStatsResponse["fraudReasons"] | undefined, val: GetFraudStatsResponse["fraudReasons"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.GetFraudStatsResponse.fraud_reasons");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    internalBinaryWrite(message: GetFraudStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 total_payments = 1; */
        if (message.totalPayments !== "0")
            writer.tag(1, WireType.Varint).int64(message.totalPayments);
        /* int64 flagged_payments = 2; */
        if (message.flaggedPayments !== "0")
            writer.tag(2, WireType.Varint).int64(message.flaggedPayments);
        /* int64 blocked_payments = 3; */
        if (message.blockedPayments !== "0")
            writer.tag(3, WireType.Varint).int64(message.blockedPayments);
        /* double fraud_rate = 4; */
        if (message.fraudRate !== 0)
            writer.tag(4, WireType.Bit64).double(message.fraudRate);
        /* int64 blacklisted_phones = 5; */
        if (message.blacklistedPhones !== "0")
            writer.tag(5, WireType.Varint).int64(message.blacklistedPhones);
        /* int64 blacklisted_ips = 6; */
        if (message.blacklistedIps !== "0")
            writer.tag(6, WireType.Varint).int64(message.blacklistedIps);
        /* int64 high_risk_users = 7; */
        if (message.highRiskUsers !== "0")
            writer.tag(7, WireType.Varint).int64(message.highRiskUsers);
        /* map<string, int64> risk_level_distribution = 8; */
        for (let k of globalThis.Object.keys(message.riskLevelDistribution))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.riskLevelDistribution[k]).join();
        /* map<string, int64> fraud_reasons = 9; */
        for (let k of globalThis.Object.keys(message.fraudReasons))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.fraudReasons[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetFraudStatsResponse
 */
export const GetFraudStatsResponse = new GetFraudStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFlaggedUsersRequest$Type extends MessageType<GetFlaggedUsersRequest> {
    constructor() {
        super("payments.GetFlaggedUsersRequest", [
            { no: 1, name: "risk_level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetFlaggedUsersRequest>): GetFlaggedUsersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.riskLevel = "";
        message.page = 0;
        message.pageSize = 0;
        if (value !== undefined)
            reflectionMergePartial<GetFlaggedUsersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFlaggedUsersRequest): GetFlaggedUsersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string risk_level */ 1:
                    message.riskLevel = reader.string();
                    break;
                case /* int32 page */ 2:
                    message.page = reader.int32();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFlaggedUsersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string risk_level = 1; */
        if (message.riskLevel !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.riskLevel);
        /* int32 page = 2; */
        if (message.page !== 0)
            writer.tag(2, WireType.Varint).int32(message.page);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetFlaggedUsersRequest
 */
export const GetFlaggedUsersRequest = new GetFlaggedUsersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFlaggedUsersResponse$Type extends MessageType<GetFlaggedUsersResponse> {
    constructor() {
        super("payments.GetFlaggedUsersResponse", [
            { no: 1, name: "users", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FlaggedUser },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetFlaggedUsersResponse>): GetFlaggedUsersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.users = [];
        message.totalCount = 0;
        message.page = 0;
        message.pageSize = 0;
        if (value !== undefined)
            reflectionMergePartial<GetFlaggedUsersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFlaggedUsersResponse): GetFlaggedUsersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.FlaggedUser users */ 1:
                    message.users.push(FlaggedUser.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                case /* int32 page */ 3:
                    message.page = reader.int32();
                    break;
                case /* int32 page_size */ 4:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFlaggedUsersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.FlaggedUser users = 1; */
        for (let i = 0; i < message.users.length; i++)
            FlaggedUser.internalBinaryWrite(message.users[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        /* int32 page = 3; */
        if (message.page !== 0)
            writer.tag(3, WireType.Varint).int32(message.page);
        /* int32 page_size = 4; */
        if (message.pageSize !== 0)
            writer.tag(4, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetFlaggedUsersResponse
 */
export const GetFlaggedUsersResponse = new GetFlaggedUsersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlaggedUser$Type extends MessageType<FlaggedUser> {
    constructor() {
        super("payments.FlaggedUser", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "phone_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "risk_level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "risk_score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "fraud_indicators", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "payment_attempts_24h", kind: "scalar", jsonName: "paymentAttempts24h", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "failed_payments", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "last_flagged_at", kind: "message", T: () => Timestamp },
            { no: 9, name: "is_blacklisted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FlaggedUser>): FlaggedUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.phoneNumber = "";
        message.riskLevel = "";
        message.riskScore = 0;
        message.fraudIndicators = [];
        message.paymentAttempts24H = "0";
        message.failedPayments = "0";
        message.isBlacklisted = false;
        if (value !== undefined)
            reflectionMergePartial<FlaggedUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlaggedUser): FlaggedUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string phone_number */ 2:
                    message.phoneNumber = reader.string();
                    break;
                case /* string risk_level */ 3:
                    message.riskLevel = reader.string();
                    break;
                case /* int32 risk_score */ 4:
                    message.riskScore = reader.int32();
                    break;
                case /* repeated string fraud_indicators */ 5:
                    message.fraudIndicators.push(reader.string());
                    break;
                case /* int64 payment_attempts_24h */ 6:
                    message.paymentAttempts24H = reader.int64().toString();
                    break;
                case /* int64 failed_payments */ 7:
                    message.failedPayments = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp last_flagged_at */ 8:
                    message.lastFlaggedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastFlaggedAt);
                    break;
                case /* bool is_blacklisted */ 9:
                    message.isBlacklisted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlaggedUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string phone_number = 2; */
        if (message.phoneNumber !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.phoneNumber);
        /* string risk_level = 3; */
        if (message.riskLevel !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.riskLevel);
        /* int32 risk_score = 4; */
        if (message.riskScore !== 0)
            writer.tag(4, WireType.Varint).int32(message.riskScore);
        /* repeated string fraud_indicators = 5; */
        for (let i = 0; i < message.fraudIndicators.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.fraudIndicators[i]);
        /* int64 payment_attempts_24h = 6; */
        if (message.paymentAttempts24H !== "0")
            writer.tag(6, WireType.Varint).int64(message.paymentAttempts24H);
        /* int64 failed_payments = 7; */
        if (message.failedPayments !== "0")
            writer.tag(7, WireType.Varint).int64(message.failedPayments);
        /* google.protobuf.Timestamp last_flagged_at = 8; */
        if (message.lastFlaggedAt)
            Timestamp.internalBinaryWrite(message.lastFlaggedAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool is_blacklisted = 9; */
        if (message.isBlacklisted !== false)
            writer.tag(9, WireType.Varint).bool(message.isBlacklisted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.FlaggedUser
 */
export const FlaggedUser = new FlaggedUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlacklistedPhonesRequest$Type extends MessageType<GetBlacklistedPhonesRequest> {
    constructor() {
        super("payments.GetBlacklistedPhonesRequest", [
            { no: 1, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetBlacklistedPhonesRequest>): GetBlacklistedPhonesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.page = 0;
        message.pageSize = 0;
        if (value !== undefined)
            reflectionMergePartial<GetBlacklistedPhonesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlacklistedPhonesRequest): GetBlacklistedPhonesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page */ 1:
                    message.page = reader.int32();
                    break;
                case /* int32 page_size */ 2:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlacklistedPhonesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page = 1; */
        if (message.page !== 0)
            writer.tag(1, WireType.Varint).int32(message.page);
        /* int32 page_size = 2; */
        if (message.pageSize !== 0)
            writer.tag(2, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetBlacklistedPhonesRequest
 */
export const GetBlacklistedPhonesRequest = new GetBlacklistedPhonesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlacklistedPhonesResponse$Type extends MessageType<GetBlacklistedPhonesResponse> {
    constructor() {
        super("payments.GetBlacklistedPhonesResponse", [
            { no: 1, name: "phones", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlacklistedPhone },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetBlacklistedPhonesResponse>): GetBlacklistedPhonesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.phones = [];
        message.totalCount = 0;
        message.page = 0;
        message.pageSize = 0;
        if (value !== undefined)
            reflectionMergePartial<GetBlacklistedPhonesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlacklistedPhonesResponse): GetBlacklistedPhonesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.BlacklistedPhone phones */ 1:
                    message.phones.push(BlacklistedPhone.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                case /* int32 page */ 3:
                    message.page = reader.int32();
                    break;
                case /* int32 page_size */ 4:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlacklistedPhonesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.BlacklistedPhone phones = 1; */
        for (let i = 0; i < message.phones.length; i++)
            BlacklistedPhone.internalBinaryWrite(message.phones[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        /* int32 page = 3; */
        if (message.page !== 0)
            writer.tag(3, WireType.Varint).int32(message.page);
        /* int32 page_size = 4; */
        if (message.pageSize !== 0)
            writer.tag(4, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetBlacklistedPhonesResponse
 */
export const GetBlacklistedPhonesResponse = new GetBlacklistedPhonesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlacklistedPhone$Type extends MessageType<BlacklistedPhone> {
    constructor() {
        super("payments.BlacklistedPhone", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "phone_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "added_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "blacklisted_at", kind: "message", T: () => Timestamp },
            { no: 6, name: "blocked_attempts", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<BlacklistedPhone>): BlacklistedPhone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.phoneNumber = "";
        message.reason = "";
        message.addedBy = "";
        message.blockedAttempts = "0";
        if (value !== undefined)
            reflectionMergePartial<BlacklistedPhone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlacklistedPhone): BlacklistedPhone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string phone_number */ 2:
                    message.phoneNumber = reader.string();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                case /* string added_by */ 4:
                    message.addedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp blacklisted_at */ 5:
                    message.blacklistedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.blacklistedAt);
                    break;
                case /* int64 blocked_attempts */ 6:
                    message.blockedAttempts = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlacklistedPhone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string phone_number = 2; */
        if (message.phoneNumber !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.phoneNumber);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        /* string added_by = 4; */
        if (message.addedBy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.addedBy);
        /* google.protobuf.Timestamp blacklisted_at = 5; */
        if (message.blacklistedAt)
            Timestamp.internalBinaryWrite(message.blacklistedAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int64 blocked_attempts = 6; */
        if (message.blockedAttempts !== "0")
            writer.tag(6, WireType.Varint).int64(message.blockedAttempts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.BlacklistedPhone
 */
export const BlacklistedPhone = new BlacklistedPhone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlacklistedIPsRequest$Type extends MessageType<GetBlacklistedIPsRequest> {
    constructor() {
        super("payments.GetBlacklistedIPsRequest", [
            { no: 1, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetBlacklistedIPsRequest>): GetBlacklistedIPsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.page = 0;
        message.pageSize = 0;
        if (value !== undefined)
            reflectionMergePartial<GetBlacklistedIPsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlacklistedIPsRequest): GetBlacklistedIPsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page */ 1:
                    message.page = reader.int32();
                    break;
                case /* int32 page_size */ 2:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlacklistedIPsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page = 1; */
        if (message.page !== 0)
            writer.tag(1, WireType.Varint).int32(message.page);
        /* int32 page_size = 2; */
        if (message.pageSize !== 0)
            writer.tag(2, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetBlacklistedIPsRequest
 */
export const GetBlacklistedIPsRequest = new GetBlacklistedIPsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlacklistedIPsResponse$Type extends MessageType<GetBlacklistedIPsResponse> {
    constructor() {
        super("payments.GetBlacklistedIPsResponse", [
            { no: 1, name: "ips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlacklistedIP },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetBlacklistedIPsResponse>): GetBlacklistedIPsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ips = [];
        message.totalCount = 0;
        message.page = 0;
        message.pageSize = 0;
        if (value !== undefined)
            reflectionMergePartial<GetBlacklistedIPsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlacklistedIPsResponse): GetBlacklistedIPsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.BlacklistedIP ips */ 1:
                    message.ips.push(BlacklistedIP.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                case /* int32 page */ 3:
                    message.page = reader.int32();
                    break;
                case /* int32 page_size */ 4:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlacklistedIPsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.BlacklistedIP ips = 1; */
        for (let i = 0; i < message.ips.length; i++)
            BlacklistedIP.internalBinaryWrite(message.ips[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        /* int32 page = 3; */
        if (message.page !== 0)
            writer.tag(3, WireType.Varint).int32(message.page);
        /* int32 page_size = 4; */
        if (message.pageSize !== 0)
            writer.tag(4, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetBlacklistedIPsResponse
 */
export const GetBlacklistedIPsResponse = new GetBlacklistedIPsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlacklistedIP$Type extends MessageType<BlacklistedIP> {
    constructor() {
        super("payments.BlacklistedIP", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "added_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "blacklisted_at", kind: "message", T: () => Timestamp },
            { no: 6, name: "blocked_attempts", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<BlacklistedIP>): BlacklistedIP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.ipAddress = "";
        message.reason = "";
        message.addedBy = "";
        message.blockedAttempts = "0";
        if (value !== undefined)
            reflectionMergePartial<BlacklistedIP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlacklistedIP): BlacklistedIP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string ip_address */ 2:
                    message.ipAddress = reader.string();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                case /* string added_by */ 4:
                    message.addedBy = reader.string();
                    break;
                case /* google.protobuf.Timestamp blacklisted_at */ 5:
                    message.blacklistedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.blacklistedAt);
                    break;
                case /* int64 blocked_attempts */ 6:
                    message.blockedAttempts = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlacklistedIP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string ip_address = 2; */
        if (message.ipAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ipAddress);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        /* string added_by = 4; */
        if (message.addedBy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.addedBy);
        /* google.protobuf.Timestamp blacklisted_at = 5; */
        if (message.blacklistedAt)
            Timestamp.internalBinaryWrite(message.blacklistedAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int64 blocked_attempts = 6; */
        if (message.blockedAttempts !== "0")
            writer.tag(6, WireType.Varint).int64(message.blockedAttempts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.BlacklistedIP
 */
export const BlacklistedIP = new BlacklistedIP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlacklistPhoneRequest$Type extends MessageType<BlacklistPhoneRequest> {
    constructor() {
        super("payments.BlacklistPhoneRequest", [
            { no: 1, name: "phone_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "admin_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlacklistPhoneRequest>): BlacklistPhoneRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.phoneNumber = "";
        message.reason = "";
        message.adminUserId = "";
        if (value !== undefined)
            reflectionMergePartial<BlacklistPhoneRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlacklistPhoneRequest): BlacklistPhoneRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string phone_number */ 1:
                    message.phoneNumber = reader.string();
                    break;
                case /* string reason */ 2:
                    message.reason = reader.string();
                    break;
                case /* string admin_user_id */ 3:
                    message.adminUserId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlacklistPhoneRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string phone_number = 1; */
        if (message.phoneNumber !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.phoneNumber);
        /* string reason = 2; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        /* string admin_user_id = 3; */
        if (message.adminUserId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.adminUserId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.BlacklistPhoneRequest
 */
export const BlacklistPhoneRequest = new BlacklistPhoneRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlacklistPhoneResponse$Type extends MessageType<BlacklistPhoneResponse> {
    constructor() {
        super("payments.BlacklistPhoneResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "phone", kind: "message", T: () => BlacklistedPhone }
        ]);
    }
    create(value?: PartialMessage<BlacklistPhoneResponse>): BlacklistPhoneResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<BlacklistPhoneResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlacklistPhoneResponse): BlacklistPhoneResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* payments.BlacklistedPhone phone */ 3:
                    message.phone = BlacklistedPhone.internalBinaryRead(reader, reader.uint32(), options, message.phone);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlacklistPhoneResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* payments.BlacklistedPhone phone = 3; */
        if (message.phone)
            BlacklistedPhone.internalBinaryWrite(message.phone, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.BlacklistPhoneResponse
 */
export const BlacklistPhoneResponse = new BlacklistPhoneResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlacklistIPRequest$Type extends MessageType<BlacklistIPRequest> {
    constructor() {
        super("payments.BlacklistIPRequest", [
            { no: 1, name: "ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "admin_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlacklistIPRequest>): BlacklistIPRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ipAddress = "";
        message.reason = "";
        message.adminUserId = "";
        if (value !== undefined)
            reflectionMergePartial<BlacklistIPRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlacklistIPRequest): BlacklistIPRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ip_address */ 1:
                    message.ipAddress = reader.string();
                    break;
                case /* string reason */ 2:
                    message.reason = reader.string();
                    break;
                case /* string admin_user_id */ 3:
                    message.adminUserId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlacklistIPRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ip_address = 1; */
        if (message.ipAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ipAddress);
        /* string reason = 2; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        /* string admin_user_id = 3; */
        if (message.adminUserId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.adminUserId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.BlacklistIPRequest
 */
export const BlacklistIPRequest = new BlacklistIPRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlacklistIPResponse$Type extends MessageType<BlacklistIPResponse> {
    constructor() {
        super("payments.BlacklistIPResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ip", kind: "message", T: () => BlacklistedIP }
        ]);
    }
    create(value?: PartialMessage<BlacklistIPResponse>): BlacklistIPResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<BlacklistIPResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlacklistIPResponse): BlacklistIPResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* payments.BlacklistedIP ip */ 3:
                    message.ip = BlacklistedIP.internalBinaryRead(reader, reader.uint32(), options, message.ip);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlacklistIPResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* payments.BlacklistedIP ip = 3; */
        if (message.ip)
            BlacklistedIP.internalBinaryWrite(message.ip, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.BlacklistIPResponse
 */
export const BlacklistIPResponse = new BlacklistIPResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemovePhoneFromBlacklistRequest$Type extends MessageType<RemovePhoneFromBlacklistRequest> {
    constructor() {
        super("payments.RemovePhoneFromBlacklistRequest", [
            { no: 1, name: "phone_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "admin_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemovePhoneFromBlacklistRequest>): RemovePhoneFromBlacklistRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.phoneNumber = "";
        message.adminUserId = "";
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<RemovePhoneFromBlacklistRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemovePhoneFromBlacklistRequest): RemovePhoneFromBlacklistRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string phone_number */ 1:
                    message.phoneNumber = reader.string();
                    break;
                case /* string admin_user_id */ 2:
                    message.adminUserId = reader.string();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemovePhoneFromBlacklistRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string phone_number = 1; */
        if (message.phoneNumber !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.phoneNumber);
        /* string admin_user_id = 2; */
        if (message.adminUserId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.adminUserId);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.RemovePhoneFromBlacklistRequest
 */
export const RemovePhoneFromBlacklistRequest = new RemovePhoneFromBlacklistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemovePhoneFromBlacklistResponse$Type extends MessageType<RemovePhoneFromBlacklistResponse> {
    constructor() {
        super("payments.RemovePhoneFromBlacklistResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemovePhoneFromBlacklistResponse>): RemovePhoneFromBlacklistResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<RemovePhoneFromBlacklistResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemovePhoneFromBlacklistResponse): RemovePhoneFromBlacklistResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemovePhoneFromBlacklistResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.RemovePhoneFromBlacklistResponse
 */
export const RemovePhoneFromBlacklistResponse = new RemovePhoneFromBlacklistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveIPFromBlacklistRequest$Type extends MessageType<RemoveIPFromBlacklistRequest> {
    constructor() {
        super("payments.RemoveIPFromBlacklistRequest", [
            { no: 1, name: "ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "admin_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveIPFromBlacklistRequest>): RemoveIPFromBlacklistRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ipAddress = "";
        message.adminUserId = "";
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<RemoveIPFromBlacklistRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveIPFromBlacklistRequest): RemoveIPFromBlacklistRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ip_address */ 1:
                    message.ipAddress = reader.string();
                    break;
                case /* string admin_user_id */ 2:
                    message.adminUserId = reader.string();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveIPFromBlacklistRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ip_address = 1; */
        if (message.ipAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ipAddress);
        /* string admin_user_id = 2; */
        if (message.adminUserId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.adminUserId);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.RemoveIPFromBlacklistRequest
 */
export const RemoveIPFromBlacklistRequest = new RemoveIPFromBlacklistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveIPFromBlacklistResponse$Type extends MessageType<RemoveIPFromBlacklistResponse> {
    constructor() {
        super("payments.RemoveIPFromBlacklistResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveIPFromBlacklistResponse>): RemoveIPFromBlacklistResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<RemoveIPFromBlacklistResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveIPFromBlacklistResponse): RemoveIPFromBlacklistResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveIPFromBlacklistResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.RemoveIPFromBlacklistResponse
 */
export const RemoveIPFromBlacklistResponse = new RemoveIPFromBlacklistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFraudRulesRequest$Type extends MessageType<GetFraudRulesRequest> {
    constructor() {
        super("payments.GetFraudRulesRequest", []);
    }
    create(value?: PartialMessage<GetFraudRulesRequest>): GetFraudRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetFraudRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFraudRulesRequest): GetFraudRulesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFraudRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetFraudRulesRequest
 */
export const GetFraudRulesRequest = new GetFraudRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFraudRulesResponse$Type extends MessageType<GetFraudRulesResponse> {
    constructor() {
        super("payments.GetFraudRulesResponse", [
            { no: 1, name: "rules", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FraudRule }
        ]);
    }
    create(value?: PartialMessage<GetFraudRulesResponse>): GetFraudRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<GetFraudRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFraudRulesResponse): GetFraudRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.FraudRule rules */ 1:
                    message.rules.push(FraudRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFraudRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.FraudRule rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            FraudRule.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetFraudRulesResponse
 */
export const GetFraudRulesResponse = new GetFraudRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FraudRule$Type extends MessageType<FraudRule> {
    constructor() {
        super("payments.FraudRule", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "rule_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parameters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "priority", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 9, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<FraudRule>): FraudRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.ruleType = "";
        message.parameters = {};
        message.isActive = false;
        message.priority = 0;
        if (value !== undefined)
            reflectionMergePartial<FraudRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FraudRule): FraudRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string rule_type */ 4:
                    message.ruleType = reader.string();
                    break;
                case /* map<string, string> parameters */ 5:
                    this.binaryReadMap5(message.parameters, reader, options);
                    break;
                case /* bool is_active */ 6:
                    message.isActive = reader.bool();
                    break;
                case /* int32 priority */ 7:
                    message.priority = reader.int32();
                    break;
                case /* google.protobuf.Timestamp created_at */ 8:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 9:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: FraudRule["parameters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FraudRule["parameters"] | undefined, val: FraudRule["parameters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.FraudRule.parameters");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: FraudRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string rule_type = 4; */
        if (message.ruleType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ruleType);
        /* map<string, string> parameters = 5; */
        for (let k of globalThis.Object.keys(message.parameters))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.parameters[k]).join();
        /* bool is_active = 6; */
        if (message.isActive !== false)
            writer.tag(6, WireType.Varint).bool(message.isActive);
        /* int32 priority = 7; */
        if (message.priority !== 0)
            writer.tag(7, WireType.Varint).int32(message.priority);
        /* google.protobuf.Timestamp created_at = 8; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 9; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.FraudRule
 */
export const FraudRule = new FraudRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateFraudRuleRequest$Type extends MessageType<UpdateFraudRuleRequest> {
    constructor() {
        super("payments.UpdateFraudRuleRequest", [
            { no: 1, name: "rule_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parameters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "admin_user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateFraudRuleRequest>): UpdateFraudRuleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ruleId = "";
        message.parameters = {};
        message.isActive = false;
        message.adminUserId = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateFraudRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateFraudRuleRequest): UpdateFraudRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string rule_id */ 1:
                    message.ruleId = reader.string();
                    break;
                case /* map<string, string> parameters */ 2:
                    this.binaryReadMap2(message.parameters, reader, options);
                    break;
                case /* bool is_active */ 3:
                    message.isActive = reader.bool();
                    break;
                case /* string admin_user_id */ 4:
                    message.adminUserId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: UpdateFraudRuleRequest["parameters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UpdateFraudRuleRequest["parameters"] | undefined, val: UpdateFraudRuleRequest["parameters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.UpdateFraudRuleRequest.parameters");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: UpdateFraudRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string rule_id = 1; */
        if (message.ruleId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ruleId);
        /* map<string, string> parameters = 2; */
        for (let k of globalThis.Object.keys(message.parameters))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.parameters[k]).join();
        /* bool is_active = 3; */
        if (message.isActive !== false)
            writer.tag(3, WireType.Varint).bool(message.isActive);
        /* string admin_user_id = 4; */
        if (message.adminUserId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.adminUserId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.UpdateFraudRuleRequest
 */
export const UpdateFraudRuleRequest = new UpdateFraudRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateFraudRuleResponse$Type extends MessageType<UpdateFraudRuleResponse> {
    constructor() {
        super("payments.UpdateFraudRuleResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "rule", kind: "message", T: () => FraudRule }
        ]);
    }
    create(value?: PartialMessage<UpdateFraudRuleResponse>): UpdateFraudRuleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateFraudRuleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateFraudRuleResponse): UpdateFraudRuleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* payments.FraudRule rule */ 3:
                    message.rule = FraudRule.internalBinaryRead(reader, reader.uint32(), options, message.rule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateFraudRuleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* payments.FraudRule rule = 3; */
        if (message.rule)
            FraudRule.internalBinaryWrite(message.rule, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.UpdateFraudRuleResponse
 */
export const UpdateFraudRuleResponse = new UpdateFraudRuleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PauseSubscriptionRequest$Type extends MessageType<PauseSubscriptionRequest> {
    constructor() {
        super("payments.PauseSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "duration_days", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PauseSubscriptionRequest>): PauseSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.userId = "";
        message.reason = "";
        message.durationDays = 0;
        if (value !== undefined)
            reflectionMergePartial<PauseSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PauseSubscriptionRequest): PauseSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                case /* int32 duration_days */ 4:
                    message.durationDays = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PauseSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        /* int32 duration_days = 4; */
        if (message.durationDays !== 0)
            writer.tag(4, WireType.Varint).int32(message.durationDays);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.PauseSubscriptionRequest
 */
export const PauseSubscriptionRequest = new PauseSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PauseSubscriptionResponse$Type extends MessageType<PauseSubscriptionResponse> {
    constructor() {
        super("payments.PauseSubscriptionResponse", [
            { no: 1, name: "subscription", kind: "message", T: () => Subscription },
            { no: 2, name: "pause_history", kind: "message", T: () => PauseHistory },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "resume_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "access_until", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PauseSubscriptionResponse>): PauseSubscriptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.resumeDate = "";
        message.accessUntil = "";
        if (value !== undefined)
            reflectionMergePartial<PauseSubscriptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PauseSubscriptionResponse): PauseSubscriptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.Subscription subscription */ 1:
                    message.subscription = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                case /* payments.PauseHistory pause_history */ 2:
                    message.pauseHistory = PauseHistory.internalBinaryRead(reader, reader.uint32(), options, message.pauseHistory);
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* string resume_date */ 4:
                    message.resumeDate = reader.string();
                    break;
                case /* string access_until */ 5:
                    message.accessUntil = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PauseSubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.Subscription subscription = 1; */
        if (message.subscription)
            Subscription.internalBinaryWrite(message.subscription, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payments.PauseHistory pause_history = 2; */
        if (message.pauseHistory)
            PauseHistory.internalBinaryWrite(message.pauseHistory, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* string resume_date = 4; */
        if (message.resumeDate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.resumeDate);
        /* string access_until = 5; */
        if (message.accessUntil !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.accessUntil);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.PauseSubscriptionResponse
 */
export const PauseSubscriptionResponse = new PauseSubscriptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResumeSubscriptionRequest$Type extends MessageType<ResumeSubscriptionRequest> {
    constructor() {
        super("payments.ResumeSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResumeSubscriptionRequest>): ResumeSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<ResumeSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResumeSubscriptionRequest): ResumeSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResumeSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ResumeSubscriptionRequest
 */
export const ResumeSubscriptionRequest = new ResumeSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResumeSubscriptionResponse$Type extends MessageType<ResumeSubscriptionResponse> {
    constructor() {
        super("payments.ResumeSubscriptionResponse", [
            { no: 1, name: "subscription", kind: "message", T: () => Subscription },
            { no: 2, name: "pause_history", kind: "message", T: () => PauseHistory },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "next_billing_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "next_billing_amount", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<ResumeSubscriptionResponse>): ResumeSubscriptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.nextBillingDate = "";
        message.nextBillingAmount = "0";
        if (value !== undefined)
            reflectionMergePartial<ResumeSubscriptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResumeSubscriptionResponse): ResumeSubscriptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.Subscription subscription */ 1:
                    message.subscription = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                case /* payments.PauseHistory pause_history */ 2:
                    message.pauseHistory = PauseHistory.internalBinaryRead(reader, reader.uint32(), options, message.pauseHistory);
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* string next_billing_date */ 4:
                    message.nextBillingDate = reader.string();
                    break;
                case /* int64 next_billing_amount */ 5:
                    message.nextBillingAmount = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResumeSubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.Subscription subscription = 1; */
        if (message.subscription)
            Subscription.internalBinaryWrite(message.subscription, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payments.PauseHistory pause_history = 2; */
        if (message.pauseHistory)
            PauseHistory.internalBinaryWrite(message.pauseHistory, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* string next_billing_date = 4; */
        if (message.nextBillingDate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.nextBillingDate);
        /* int64 next_billing_amount = 5; */
        if (message.nextBillingAmount !== "0")
            writer.tag(5, WireType.Varint).int64(message.nextBillingAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ResumeSubscriptionResponse
 */
export const ResumeSubscriptionResponse = new ResumeSubscriptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPauseStatusRequest$Type extends MessageType<GetPauseStatusRequest> {
    constructor() {
        super("payments.GetPauseStatusRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPauseStatusRequest>): GetPauseStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPauseStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPauseStatusRequest): GetPauseStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPauseStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPauseStatusRequest
 */
export const GetPauseStatusRequest = new GetPauseStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPauseStatusResponse$Type extends MessageType<GetPauseStatusResponse> {
    constructor() {
        super("payments.GetPauseStatusResponse", [
            { no: 1, name: "is_paused", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "paused_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "resume_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "days_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "can_pause", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "cannot_pause_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "history", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PauseHistory }
        ]);
    }
    create(value?: PartialMessage<GetPauseStatusResponse>): GetPauseStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isPaused = false;
        message.pausedAt = "";
        message.resumeAt = "";
        message.daysRemaining = 0;
        message.canPause = false;
        message.cannotPauseReason = "";
        message.history = [];
        if (value !== undefined)
            reflectionMergePartial<GetPauseStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPauseStatusResponse): GetPauseStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_paused */ 1:
                    message.isPaused = reader.bool();
                    break;
                case /* string paused_at */ 2:
                    message.pausedAt = reader.string();
                    break;
                case /* string resume_at */ 3:
                    message.resumeAt = reader.string();
                    break;
                case /* int32 days_remaining */ 4:
                    message.daysRemaining = reader.int32();
                    break;
                case /* bool can_pause */ 5:
                    message.canPause = reader.bool();
                    break;
                case /* string cannot_pause_reason */ 6:
                    message.cannotPauseReason = reader.string();
                    break;
                case /* repeated payments.PauseHistory history */ 7:
                    message.history.push(PauseHistory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPauseStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_paused = 1; */
        if (message.isPaused !== false)
            writer.tag(1, WireType.Varint).bool(message.isPaused);
        /* string paused_at = 2; */
        if (message.pausedAt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pausedAt);
        /* string resume_at = 3; */
        if (message.resumeAt !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.resumeAt);
        /* int32 days_remaining = 4; */
        if (message.daysRemaining !== 0)
            writer.tag(4, WireType.Varint).int32(message.daysRemaining);
        /* bool can_pause = 5; */
        if (message.canPause !== false)
            writer.tag(5, WireType.Varint).bool(message.canPause);
        /* string cannot_pause_reason = 6; */
        if (message.cannotPauseReason !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.cannotPauseReason);
        /* repeated payments.PauseHistory history = 7; */
        for (let i = 0; i < message.history.length; i++)
            PauseHistory.internalBinaryWrite(message.history[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPauseStatusResponse
 */
export const GetPauseStatusResponse = new GetPauseStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PauseHistory$Type extends MessageType<PauseHistory> {
    constructor() {
        super("payments.PauseHistory", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "paused_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "resume_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "resumed_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "pause_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "duration_days", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "days_remaining", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PauseHistory>): PauseHistory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.subscriptionId = "";
        message.userId = "";
        message.pausedAt = "";
        message.resumeAt = "";
        message.resumedAt = "";
        message.pauseReason = "";
        message.status = "";
        message.durationDays = 0;
        message.daysRemaining = 0;
        if (value !== undefined)
            reflectionMergePartial<PauseHistory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PauseHistory): PauseHistory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string subscription_id */ 2:
                    message.subscriptionId = reader.string();
                    break;
                case /* string user_id */ 3:
                    message.userId = reader.string();
                    break;
                case /* string paused_at */ 4:
                    message.pausedAt = reader.string();
                    break;
                case /* string resume_at */ 5:
                    message.resumeAt = reader.string();
                    break;
                case /* string resumed_at */ 6:
                    message.resumedAt = reader.string();
                    break;
                case /* string pause_reason */ 7:
                    message.pauseReason = reader.string();
                    break;
                case /* string status */ 8:
                    message.status = reader.string();
                    break;
                case /* int32 duration_days */ 9:
                    message.durationDays = reader.int32();
                    break;
                case /* int32 days_remaining */ 10:
                    message.daysRemaining = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PauseHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string subscription_id = 2; */
        if (message.subscriptionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subscriptionId);
        /* string user_id = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        /* string paused_at = 4; */
        if (message.pausedAt !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pausedAt);
        /* string resume_at = 5; */
        if (message.resumeAt !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.resumeAt);
        /* string resumed_at = 6; */
        if (message.resumedAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.resumedAt);
        /* string pause_reason = 7; */
        if (message.pauseReason !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.pauseReason);
        /* string status = 8; */
        if (message.status !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.status);
        /* int32 duration_days = 9; */
        if (message.durationDays !== 0)
            writer.tag(9, WireType.Varint).int32(message.durationDays);
        /* int32 days_remaining = 10; */
        if (message.daysRemaining !== 0)
            writer.tag(10, WireType.Varint).int32(message.daysRemaining);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.PauseHistory
 */
export const PauseHistory = new PauseHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitiateCancellationRequest$Type extends MessageType<InitiateCancellationRequest> {
    constructor() {
        super("payments.InitiateCancellationRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reason_category", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "reason_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "feedback", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "user_agent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InitiateCancellationRequest>): InitiateCancellationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscriptionId = "";
        message.userId = "";
        message.reasonCategory = "";
        message.reasonText = "";
        message.feedback = "";
        message.userAgent = "";
        message.ipAddress = "";
        if (value !== undefined)
            reflectionMergePartial<InitiateCancellationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitiateCancellationRequest): InitiateCancellationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subscription_id */ 1:
                    message.subscriptionId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                case /* string reason_category */ 3:
                    message.reasonCategory = reader.string();
                    break;
                case /* string reason_text */ 4:
                    message.reasonText = reader.string();
                    break;
                case /* string feedback */ 5:
                    message.feedback = reader.string();
                    break;
                case /* string user_agent */ 6:
                    message.userAgent = reader.string();
                    break;
                case /* string ip_address */ 7:
                    message.ipAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitiateCancellationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subscription_id = 1; */
        if (message.subscriptionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subscriptionId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string reason_category = 3; */
        if (message.reasonCategory !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reasonCategory);
        /* string reason_text = 4; */
        if (message.reasonText !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.reasonText);
        /* string feedback = 5; */
        if (message.feedback !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.feedback);
        /* string user_agent = 6; */
        if (message.userAgent !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.userAgent);
        /* string ip_address = 7; */
        if (message.ipAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.ipAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.InitiateCancellationRequest
 */
export const InitiateCancellationRequest = new InitiateCancellationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitiateCancellationResponse$Type extends MessageType<InitiateCancellationResponse> {
    constructor() {
        super("payments.InitiateCancellationResponse", [
            { no: 1, name: "cancellation_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "effective_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "access_until", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "retention_offers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RetentionOffer },
            { no: 6, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InitiateCancellationResponse>): InitiateCancellationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancellationRequestId = "";
        message.status = "";
        message.effectiveDate = "";
        message.accessUntil = "";
        message.retentionOffers = [];
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<InitiateCancellationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitiateCancellationResponse): InitiateCancellationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cancellation_request_id */ 1:
                    message.cancellationRequestId = reader.string();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* string effective_date */ 3:
                    message.effectiveDate = reader.string();
                    break;
                case /* string access_until */ 4:
                    message.accessUntil = reader.string();
                    break;
                case /* repeated payments.RetentionOffer retention_offers */ 5:
                    message.retentionOffers.push(RetentionOffer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string message */ 6:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitiateCancellationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cancellation_request_id = 1; */
        if (message.cancellationRequestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cancellationRequestId);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* string effective_date = 3; */
        if (message.effectiveDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.effectiveDate);
        /* string access_until = 4; */
        if (message.accessUntil !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accessUntil);
        /* repeated payments.RetentionOffer retention_offers = 5; */
        for (let i = 0; i < message.retentionOffers.length; i++)
            RetentionOffer.internalBinaryWrite(message.retentionOffers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string message = 6; */
        if (message.message !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.InitiateCancellationResponse
 */
export const InitiateCancellationResponse = new InitiateCancellationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetentionOffer$Type extends MessageType<RetentionOffer> {
    constructor() {
        super("payments.RetentionOffer", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "current_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "new_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "discount_percent", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "duration_months", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "savings", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<RetentionOffer>): RetentionOffer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.title = "";
        message.description = "";
        message.currentPrice = "";
        message.newPrice = "";
        message.discountPercent = 0;
        message.durationMonths = 0;
        message.action = "";
        message.savings = 0;
        if (value !== undefined)
            reflectionMergePartial<RetentionOffer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetentionOffer): RetentionOffer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string current_price */ 4:
                    message.currentPrice = reader.string();
                    break;
                case /* string new_price */ 5:
                    message.newPrice = reader.string();
                    break;
                case /* int32 discount_percent */ 6:
                    message.discountPercent = reader.int32();
                    break;
                case /* int32 duration_months */ 7:
                    message.durationMonths = reader.int32();
                    break;
                case /* string action */ 8:
                    message.action = reader.string();
                    break;
                case /* double savings */ 9:
                    message.savings = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetentionOffer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string current_price = 4; */
        if (message.currentPrice !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.currentPrice);
        /* string new_price = 5; */
        if (message.newPrice !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.newPrice);
        /* int32 discount_percent = 6; */
        if (message.discountPercent !== 0)
            writer.tag(6, WireType.Varint).int32(message.discountPercent);
        /* int32 duration_months = 7; */
        if (message.durationMonths !== 0)
            writer.tag(7, WireType.Varint).int32(message.durationMonths);
        /* string action = 8; */
        if (message.action !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.action);
        /* double savings = 9; */
        if (message.savings !== 0)
            writer.tag(9, WireType.Bit64).double(message.savings);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.RetentionOffer
 */
export const RetentionOffer = new RetentionOffer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AcceptRetentionOfferRequest$Type extends MessageType<AcceptRetentionOfferRequest> {
    constructor() {
        super("payments.AcceptRetentionOfferRequest", [
            { no: 1, name: "cancellation_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "offer_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "offer_details", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<AcceptRetentionOfferRequest>): AcceptRetentionOfferRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancellationRequestId = "";
        message.userId = "";
        message.offerType = "";
        message.offerDetails = {};
        if (value !== undefined)
            reflectionMergePartial<AcceptRetentionOfferRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AcceptRetentionOfferRequest): AcceptRetentionOfferRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cancellation_request_id */ 1:
                    message.cancellationRequestId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                case /* string offer_type */ 3:
                    message.offerType = reader.string();
                    break;
                case /* map<string, string> offer_details */ 4:
                    this.binaryReadMap4(message.offerDetails, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: AcceptRetentionOfferRequest["offerDetails"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AcceptRetentionOfferRequest["offerDetails"] | undefined, val: AcceptRetentionOfferRequest["offerDetails"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.AcceptRetentionOfferRequest.offer_details");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AcceptRetentionOfferRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cancellation_request_id = 1; */
        if (message.cancellationRequestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cancellationRequestId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string offer_type = 3; */
        if (message.offerType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.offerType);
        /* map<string, string> offer_details = 4; */
        for (let k of globalThis.Object.keys(message.offerDetails))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.offerDetails[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.AcceptRetentionOfferRequest
 */
export const AcceptRetentionOfferRequest = new AcceptRetentionOfferRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AcceptRetentionOfferResponse$Type extends MessageType<AcceptRetentionOfferResponse> {
    constructor() {
        super("payments.AcceptRetentionOfferResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subscription", kind: "message", T: () => Subscription }
        ]);
    }
    create(value?: PartialMessage<AcceptRetentionOfferResponse>): AcceptRetentionOfferResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<AcceptRetentionOfferResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AcceptRetentionOfferResponse): AcceptRetentionOfferResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* payments.Subscription subscription */ 3:
                    message.subscription = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AcceptRetentionOfferResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* payments.Subscription subscription = 3; */
        if (message.subscription)
            Subscription.internalBinaryWrite(message.subscription, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.AcceptRetentionOfferResponse
 */
export const AcceptRetentionOfferResponse = new AcceptRetentionOfferResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfirmCancellationRequest$Type extends MessageType<ConfirmCancellationRequest> {
    constructor() {
        super("payments.ConfirmCancellationRequest", [
            { no: 1, name: "cancellation_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConfirmCancellationRequest>): ConfirmCancellationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancellationRequestId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<ConfirmCancellationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfirmCancellationRequest): ConfirmCancellationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cancellation_request_id */ 1:
                    message.cancellationRequestId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfirmCancellationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cancellation_request_id = 1; */
        if (message.cancellationRequestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cancellationRequestId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ConfirmCancellationRequest
 */
export const ConfirmCancellationRequest = new ConfirmCancellationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfirmCancellationResponse$Type extends MessageType<ConfirmCancellationResponse> {
    constructor() {
        super("payments.ConfirmCancellationResponse", [
            { no: 1, name: "cancellation_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "effective_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "access_until", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "can_undo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "undo_deadline", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConfirmCancellationResponse>): ConfirmCancellationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancellationRequestId = "";
        message.status = "";
        message.effectiveDate = "";
        message.accessUntil = "";
        message.canUndo = false;
        message.undoDeadline = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ConfirmCancellationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfirmCancellationResponse): ConfirmCancellationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cancellation_request_id */ 1:
                    message.cancellationRequestId = reader.string();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* string effective_date */ 3:
                    message.effectiveDate = reader.string();
                    break;
                case /* string access_until */ 4:
                    message.accessUntil = reader.string();
                    break;
                case /* bool can_undo */ 5:
                    message.canUndo = reader.bool();
                    break;
                case /* string undo_deadline */ 6:
                    message.undoDeadline = reader.string();
                    break;
                case /* string message */ 7:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfirmCancellationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cancellation_request_id = 1; */
        if (message.cancellationRequestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cancellationRequestId);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* string effective_date = 3; */
        if (message.effectiveDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.effectiveDate);
        /* string access_until = 4; */
        if (message.accessUntil !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accessUntil);
        /* bool can_undo = 5; */
        if (message.canUndo !== false)
            writer.tag(5, WireType.Varint).bool(message.canUndo);
        /* string undo_deadline = 6; */
        if (message.undoDeadline !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.undoDeadline);
        /* string message = 7; */
        if (message.message !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ConfirmCancellationResponse
 */
export const ConfirmCancellationResponse = new ConfirmCancellationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoCancellationRequest$Type extends MessageType<UndoCancellationRequest> {
    constructor() {
        super("payments.UndoCancellationRequest", [
            { no: 1, name: "cancellation_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UndoCancellationRequest>): UndoCancellationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancellationRequestId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<UndoCancellationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UndoCancellationRequest): UndoCancellationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cancellation_request_id */ 1:
                    message.cancellationRequestId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UndoCancellationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cancellation_request_id = 1; */
        if (message.cancellationRequestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cancellationRequestId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.UndoCancellationRequest
 */
export const UndoCancellationRequest = new UndoCancellationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoCancellationResponse$Type extends MessageType<UndoCancellationResponse> {
    constructor() {
        super("payments.UndoCancellationResponse", [
            { no: 1, name: "cancellation_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "subscription", kind: "message", T: () => Subscription }
        ]);
    }
    create(value?: PartialMessage<UndoCancellationResponse>): UndoCancellationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancellationRequestId = "";
        message.status = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<UndoCancellationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UndoCancellationResponse): UndoCancellationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cancellation_request_id */ 1:
                    message.cancellationRequestId = reader.string();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* payments.Subscription subscription */ 4:
                    message.subscription = Subscription.internalBinaryRead(reader, reader.uint32(), options, message.subscription);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UndoCancellationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cancellation_request_id = 1; */
        if (message.cancellationRequestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cancellationRequestId);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* payments.Subscription subscription = 4; */
        if (message.subscription)
            Subscription.internalBinaryWrite(message.subscription, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.UndoCancellationResponse
 */
export const UndoCancellationResponse = new UndoCancellationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCancellationStatusRequest$Type extends MessageType<GetCancellationStatusRequest> {
    constructor() {
        super("payments.GetCancellationStatusRequest", [
            { no: 1, name: "cancellation_request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCancellationStatusRequest>): GetCancellationStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancellationRequestId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetCancellationStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCancellationStatusRequest): GetCancellationStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cancellation_request_id */ 1:
                    message.cancellationRequestId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCancellationStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cancellation_request_id = 1; */
        if (message.cancellationRequestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cancellationRequestId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetCancellationStatusRequest
 */
export const GetCancellationStatusRequest = new GetCancellationStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCancellationStatusResponse$Type extends MessageType<GetCancellationStatusResponse> {
    constructor() {
        super("payments.GetCancellationStatusResponse", [
            { no: 1, name: "cancellation_request", kind: "message", T: () => CancellationRequest },
            { no: 2, name: "can_undo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "days_until_effective", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetCancellationStatusResponse>): GetCancellationStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.canUndo = false;
        message.daysUntilEffective = 0;
        if (value !== undefined)
            reflectionMergePartial<GetCancellationStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCancellationStatusResponse): GetCancellationStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.CancellationRequest cancellation_request */ 1:
                    message.cancellationRequest = CancellationRequest.internalBinaryRead(reader, reader.uint32(), options, message.cancellationRequest);
                    break;
                case /* bool can_undo */ 2:
                    message.canUndo = reader.bool();
                    break;
                case /* int32 days_until_effective */ 3:
                    message.daysUntilEffective = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCancellationStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.CancellationRequest cancellation_request = 1; */
        if (message.cancellationRequest)
            CancellationRequest.internalBinaryWrite(message.cancellationRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool can_undo = 2; */
        if (message.canUndo !== false)
            writer.tag(2, WireType.Varint).bool(message.canUndo);
        /* int32 days_until_effective = 3; */
        if (message.daysUntilEffective !== 0)
            writer.tag(3, WireType.Varint).int32(message.daysUntilEffective);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetCancellationStatusResponse
 */
export const GetCancellationStatusResponse = new GetCancellationStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancellationRequest$Type extends MessageType<CancellationRequest> {
    constructor() {
        super("payments.CancellationRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscription_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "reason_category", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "reason_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "feedback", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "requested_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "retention_offer_shown", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "retention_offer_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "retention_offer_accepted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "effective_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "completed_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancellationRequest>): CancellationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.subscriptionId = "";
        message.userId = "";
        message.reasonCategory = "";
        message.reasonText = "";
        message.feedback = "";
        message.requestedAt = "";
        message.retentionOfferShown = false;
        message.retentionOfferType = "";
        message.retentionOfferAccepted = false;
        message.status = "";
        message.effectiveDate = "";
        message.completedAt = "";
        if (value !== undefined)
            reflectionMergePartial<CancellationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancellationRequest): CancellationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string subscription_id */ 2:
                    message.subscriptionId = reader.string();
                    break;
                case /* string user_id */ 3:
                    message.userId = reader.string();
                    break;
                case /* string reason_category */ 4:
                    message.reasonCategory = reader.string();
                    break;
                case /* string reason_text */ 5:
                    message.reasonText = reader.string();
                    break;
                case /* string feedback */ 6:
                    message.feedback = reader.string();
                    break;
                case /* string requested_at */ 7:
                    message.requestedAt = reader.string();
                    break;
                case /* bool retention_offer_shown */ 8:
                    message.retentionOfferShown = reader.bool();
                    break;
                case /* string retention_offer_type */ 9:
                    message.retentionOfferType = reader.string();
                    break;
                case /* bool retention_offer_accepted */ 10:
                    message.retentionOfferAccepted = reader.bool();
                    break;
                case /* string status */ 11:
                    message.status = reader.string();
                    break;
                case /* string effective_date */ 12:
                    message.effectiveDate = reader.string();
                    break;
                case /* string completed_at */ 13:
                    message.completedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancellationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string subscription_id = 2; */
        if (message.subscriptionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subscriptionId);
        /* string user_id = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        /* string reason_category = 4; */
        if (message.reasonCategory !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.reasonCategory);
        /* string reason_text = 5; */
        if (message.reasonText !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reasonText);
        /* string feedback = 6; */
        if (message.feedback !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.feedback);
        /* string requested_at = 7; */
        if (message.requestedAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.requestedAt);
        /* bool retention_offer_shown = 8; */
        if (message.retentionOfferShown !== false)
            writer.tag(8, WireType.Varint).bool(message.retentionOfferShown);
        /* string retention_offer_type = 9; */
        if (message.retentionOfferType !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.retentionOfferType);
        /* bool retention_offer_accepted = 10; */
        if (message.retentionOfferAccepted !== false)
            writer.tag(10, WireType.Varint).bool(message.retentionOfferAccepted);
        /* string status = 11; */
        if (message.status !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.status);
        /* string effective_date = 12; */
        if (message.effectiveDate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.effectiveDate);
        /* string completed_at = 13; */
        if (message.completedAt !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.completedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CancellationRequest
 */
export const CancellationRequest = new CancellationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAnalyticsRequest$Type extends MessageType<GetAnalyticsRequest> {
    constructor() {
        super("payments.GetAnalyticsRequest", [
            { no: 1, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAnalyticsRequest>): GetAnalyticsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startDate = "";
        message.endDate = "";
        if (value !== undefined)
            reflectionMergePartial<GetAnalyticsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAnalyticsRequest): GetAnalyticsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string start_date */ 1:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 2:
                    message.endDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAnalyticsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string start_date = 1; */
        if (message.startDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 2; */
        if (message.endDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetAnalyticsRequest
 */
export const GetAnalyticsRequest = new GetAnalyticsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAnalyticsResponse$Type extends MessageType<GetAnalyticsResponse> {
    constructor() {
        super("payments.GetAnalyticsResponse", [
            { no: 1, name: "metrics", kind: "message", T: () => AnalyticsMetrics }
        ]);
    }
    create(value?: PartialMessage<GetAnalyticsResponse>): GetAnalyticsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAnalyticsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAnalyticsResponse): GetAnalyticsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.AnalyticsMetrics metrics */ 1:
                    message.metrics = AnalyticsMetrics.internalBinaryRead(reader, reader.uint32(), options, message.metrics);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAnalyticsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.AnalyticsMetrics metrics = 1; */
        if (message.metrics)
            AnalyticsMetrics.internalBinaryWrite(message.metrics, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetAnalyticsResponse
 */
export const GetAnalyticsResponse = new GetAnalyticsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMRRMetricsRequest$Type extends MessageType<GetMRRMetricsRequest> {
    constructor() {
        super("payments.GetMRRMetricsRequest", [
            { no: 1, name: "as_of_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMRRMetricsRequest>): GetMRRMetricsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.asOfDate = "";
        if (value !== undefined)
            reflectionMergePartial<GetMRRMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMRRMetricsRequest): GetMRRMetricsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string as_of_date */ 1:
                    message.asOfDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMRRMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string as_of_date = 1; */
        if (message.asOfDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.asOfDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetMRRMetricsRequest
 */
export const GetMRRMetricsRequest = new GetMRRMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMRRMetricsResponse$Type extends MessageType<GetMRRMetricsResponse> {
    constructor() {
        super("payments.GetMRRMetricsResponse", [
            { no: 1, name: "mrr", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "arr", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "mrr_growth", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "mrr_by_plan", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } }
        ]);
    }
    create(value?: PartialMessage<GetMRRMetricsResponse>): GetMRRMetricsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mrr = "0";
        message.arr = "0";
        message.mrrGrowth = 0;
        message.mrrByPlan = {};
        if (value !== undefined)
            reflectionMergePartial<GetMRRMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMRRMetricsResponse): GetMRRMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 mrr */ 1:
                    message.mrr = reader.int64().toString();
                    break;
                case /* int64 arr */ 2:
                    message.arr = reader.int64().toString();
                    break;
                case /* double mrr_growth */ 3:
                    message.mrrGrowth = reader.double();
                    break;
                case /* map<string, int64> mrr_by_plan */ 4:
                    this.binaryReadMap4(message.mrrByPlan, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: GetMRRMetricsResponse["mrrByPlan"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetMRRMetricsResponse["mrrByPlan"] | undefined, val: GetMRRMetricsResponse["mrrByPlan"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.GetMRRMetricsResponse.mrr_by_plan");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    internalBinaryWrite(message: GetMRRMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 mrr = 1; */
        if (message.mrr !== "0")
            writer.tag(1, WireType.Varint).int64(message.mrr);
        /* int64 arr = 2; */
        if (message.arr !== "0")
            writer.tag(2, WireType.Varint).int64(message.arr);
        /* double mrr_growth = 3; */
        if (message.mrrGrowth !== 0)
            writer.tag(3, WireType.Bit64).double(message.mrrGrowth);
        /* map<string, int64> mrr_by_plan = 4; */
        for (let k of globalThis.Object.keys(message.mrrByPlan))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.mrrByPlan[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetMRRMetricsResponse
 */
export const GetMRRMetricsResponse = new GetMRRMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChurnMetricsRequest$Type extends MessageType<GetChurnMetricsRequest> {
    constructor() {
        super("payments.GetChurnMetricsRequest", [
            { no: 1, name: "month", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetChurnMetricsRequest>): GetChurnMetricsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.month = "";
        if (value !== undefined)
            reflectionMergePartial<GetChurnMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChurnMetricsRequest): GetChurnMetricsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string month */ 1:
                    message.month = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChurnMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string month = 1; */
        if (message.month !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.month);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetChurnMetricsRequest
 */
export const GetChurnMetricsRequest = new GetChurnMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChurnMetricsResponse$Type extends MessageType<GetChurnMetricsResponse> {
    constructor() {
        super("payments.GetChurnMetricsResponse", [
            { no: 1, name: "churn_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "churned_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "churn_reasons", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } }
        ]);
    }
    create(value?: PartialMessage<GetChurnMetricsResponse>): GetChurnMetricsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.churnRate = 0;
        message.churnedCount = "0";
        message.churnReasons = {};
        if (value !== undefined)
            reflectionMergePartial<GetChurnMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChurnMetricsResponse): GetChurnMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double churn_rate */ 1:
                    message.churnRate = reader.double();
                    break;
                case /* int64 churned_count */ 2:
                    message.churnedCount = reader.int64().toString();
                    break;
                case /* map<string, int64> churn_reasons */ 3:
                    this.binaryReadMap3(message.churnReasons, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: GetChurnMetricsResponse["churnReasons"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetChurnMetricsResponse["churnReasons"] | undefined, val: GetChurnMetricsResponse["churnReasons"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.GetChurnMetricsResponse.churn_reasons");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    internalBinaryWrite(message: GetChurnMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double churn_rate = 1; */
        if (message.churnRate !== 0)
            writer.tag(1, WireType.Bit64).double(message.churnRate);
        /* int64 churned_count = 2; */
        if (message.churnedCount !== "0")
            writer.tag(2, WireType.Varint).int64(message.churnedCount);
        /* map<string, int64> churn_reasons = 3; */
        for (let k of globalThis.Object.keys(message.churnReasons))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.churnReasons[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetChurnMetricsResponse
 */
export const GetChurnMetricsResponse = new GetChurnMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRevenueMetricsRequest$Type extends MessageType<GetRevenueMetricsRequest> {
    constructor() {
        super("payments.GetRevenueMetricsRequest", [
            { no: 1, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetRevenueMetricsRequest>): GetRevenueMetricsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startDate = "";
        message.endDate = "";
        if (value !== undefined)
            reflectionMergePartial<GetRevenueMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRevenueMetricsRequest): GetRevenueMetricsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string start_date */ 1:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 2:
                    message.endDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRevenueMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string start_date = 1; */
        if (message.startDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 2; */
        if (message.endDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetRevenueMetricsRequest
 */
export const GetRevenueMetricsRequest = new GetRevenueMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRevenueMetricsResponse$Type extends MessageType<GetRevenueMetricsResponse> {
    constructor() {
        super("payments.GetRevenueMetricsResponse", [
            { no: 1, name: "revenue", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "revenue_growth", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "revenue_by_plan", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } }
        ]);
    }
    create(value?: PartialMessage<GetRevenueMetricsResponse>): GetRevenueMetricsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.revenue = "0";
        message.revenueGrowth = 0;
        message.revenueByPlan = {};
        if (value !== undefined)
            reflectionMergePartial<GetRevenueMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRevenueMetricsResponse): GetRevenueMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 revenue */ 1:
                    message.revenue = reader.int64().toString();
                    break;
                case /* double revenue_growth */ 2:
                    message.revenueGrowth = reader.double();
                    break;
                case /* map<string, int64> revenue_by_plan */ 3:
                    this.binaryReadMap3(message.revenueByPlan, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: GetRevenueMetricsResponse["revenueByPlan"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetRevenueMetricsResponse["revenueByPlan"] | undefined, val: GetRevenueMetricsResponse["revenueByPlan"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.GetRevenueMetricsResponse.revenue_by_plan");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    internalBinaryWrite(message: GetRevenueMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 revenue = 1; */
        if (message.revenue !== "0")
            writer.tag(1, WireType.Varint).int64(message.revenue);
        /* double revenue_growth = 2; */
        if (message.revenueGrowth !== 0)
            writer.tag(2, WireType.Bit64).double(message.revenueGrowth);
        /* map<string, int64> revenue_by_plan = 3; */
        for (let k of globalThis.Object.keys(message.revenueByPlan))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.revenueByPlan[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetRevenueMetricsResponse
 */
export const GetRevenueMetricsResponse = new GetRevenueMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCohortAnalysisRequest$Type extends MessageType<GetCohortAnalysisRequest> {
    constructor() {
        super("payments.GetCohortAnalysisRequest", [
            { no: 1, name: "cohort_month", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "months_to_track", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetCohortAnalysisRequest>): GetCohortAnalysisRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cohortMonth = "";
        message.monthsToTrack = 0;
        if (value !== undefined)
            reflectionMergePartial<GetCohortAnalysisRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCohortAnalysisRequest): GetCohortAnalysisRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cohort_month */ 1:
                    message.cohortMonth = reader.string();
                    break;
                case /* int32 months_to_track */ 2:
                    message.monthsToTrack = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCohortAnalysisRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cohort_month = 1; */
        if (message.cohortMonth !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cohortMonth);
        /* int32 months_to_track = 2; */
        if (message.monthsToTrack !== 0)
            writer.tag(2, WireType.Varint).int32(message.monthsToTrack);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetCohortAnalysisRequest
 */
export const GetCohortAnalysisRequest = new GetCohortAnalysisRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCohortAnalysisResponse$Type extends MessageType<GetCohortAnalysisResponse> {
    constructor() {
        super("payments.GetCohortAnalysisResponse", [
            { no: 1, name: "cohort", kind: "message", T: () => CohortAnalysis }
        ]);
    }
    create(value?: PartialMessage<GetCohortAnalysisResponse>): GetCohortAnalysisResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetCohortAnalysisResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCohortAnalysisResponse): GetCohortAnalysisResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.CohortAnalysis cohort */ 1:
                    message.cohort = CohortAnalysis.internalBinaryRead(reader, reader.uint32(), options, message.cohort);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCohortAnalysisResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.CohortAnalysis cohort = 1; */
        if (message.cohort)
            CohortAnalysis.internalBinaryWrite(message.cohort, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetCohortAnalysisResponse
 */
export const GetCohortAnalysisResponse = new GetCohortAnalysisResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForecastRevenueRequest$Type extends MessageType<ForecastRevenueRequest> {
    constructor() {
        super("payments.ForecastRevenueRequest", [
            { no: 1, name: "months_ahead", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ForecastRevenueRequest>): ForecastRevenueRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.monthsAhead = 0;
        if (value !== undefined)
            reflectionMergePartial<ForecastRevenueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForecastRevenueRequest): ForecastRevenueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 months_ahead */ 1:
                    message.monthsAhead = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForecastRevenueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 months_ahead = 1; */
        if (message.monthsAhead !== 0)
            writer.tag(1, WireType.Varint).int32(message.monthsAhead);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ForecastRevenueRequest
 */
export const ForecastRevenueRequest = new ForecastRevenueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForecastRevenueResponse$Type extends MessageType<ForecastRevenueResponse> {
    constructor() {
        super("payments.ForecastRevenueResponse", [
            { no: 1, name: "forecasts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RevenueForecast }
        ]);
    }
    create(value?: PartialMessage<ForecastRevenueResponse>): ForecastRevenueResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forecasts = [];
        if (value !== undefined)
            reflectionMergePartial<ForecastRevenueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForecastRevenueResponse): ForecastRevenueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.RevenueForecast forecasts */ 1:
                    message.forecasts.push(RevenueForecast.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForecastRevenueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.RevenueForecast forecasts = 1; */
        for (let i = 0; i < message.forecasts.length; i++)
            RevenueForecast.internalBinaryWrite(message.forecasts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.ForecastRevenueResponse
 */
export const ForecastRevenueResponse = new ForecastRevenueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserAnalyticsRequest$Type extends MessageType<GetUserAnalyticsRequest> {
    constructor() {
        super("payments.GetUserAnalyticsRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserAnalyticsRequest>): GetUserAnalyticsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserAnalyticsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserAnalyticsRequest): GetUserAnalyticsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserAnalyticsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetUserAnalyticsRequest
 */
export const GetUserAnalyticsRequest = new GetUserAnalyticsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserAnalyticsResponse$Type extends MessageType<GetUserAnalyticsResponse> {
    constructor() {
        super("payments.GetUserAnalyticsResponse", [
            { no: 1, name: "analytics", kind: "message", T: () => UserAnalytics }
        ]);
    }
    create(value?: PartialMessage<GetUserAnalyticsResponse>): GetUserAnalyticsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetUserAnalyticsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserAnalyticsResponse): GetUserAnalyticsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.UserAnalytics analytics */ 1:
                    message.analytics = UserAnalytics.internalBinaryRead(reader, reader.uint32(), options, message.analytics);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserAnalyticsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.UserAnalytics analytics = 1; */
        if (message.analytics)
            UserAnalytics.internalBinaryWrite(message.analytics, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetUserAnalyticsResponse
 */
export const GetUserAnalyticsResponse = new GetUserAnalyticsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnalyticsMetrics$Type extends MessageType<AnalyticsMetrics> {
    constructor() {
        super("payments.AnalyticsMetrics", [
            { no: 1, name: "mrr", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "arr", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "mrr_growth", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "mrr_by_plan", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } },
            { no: 5, name: "active_subscriptions", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "trial_subscriptions", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "paused_subscriptions", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "cancelled_subscriptions", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 9, name: "churn_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "churned_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 11, name: "churn_reasons", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } },
            { no: 12, name: "revenue", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 13, name: "revenue_growth", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "revenue_by_plan", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } },
            { no: 15, name: "payment_success_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "total_payments", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 17, name: "successful_payments", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 18, name: "failed_payments", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 19, name: "total_customers", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 20, name: "new_customers", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 21, name: "average_lifetime_value", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 22, name: "period_start", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "period_end", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AnalyticsMetrics>): AnalyticsMetrics {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mrr = "0";
        message.arr = "0";
        message.mrrGrowth = 0;
        message.mrrByPlan = {};
        message.activeSubscriptions = "0";
        message.trialSubscriptions = "0";
        message.pausedSubscriptions = "0";
        message.cancelledSubscriptions = "0";
        message.churnRate = 0;
        message.churnedCount = "0";
        message.churnReasons = {};
        message.revenue = "0";
        message.revenueGrowth = 0;
        message.revenueByPlan = {};
        message.paymentSuccessRate = 0;
        message.totalPayments = "0";
        message.successfulPayments = "0";
        message.failedPayments = "0";
        message.totalCustomers = "0";
        message.newCustomers = "0";
        message.averageLifetimeValue = "0";
        message.periodStart = "";
        message.periodEnd = "";
        if (value !== undefined)
            reflectionMergePartial<AnalyticsMetrics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnalyticsMetrics): AnalyticsMetrics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 mrr */ 1:
                    message.mrr = reader.int64().toString();
                    break;
                case /* int64 arr */ 2:
                    message.arr = reader.int64().toString();
                    break;
                case /* double mrr_growth */ 3:
                    message.mrrGrowth = reader.double();
                    break;
                case /* map<string, int64> mrr_by_plan */ 4:
                    this.binaryReadMap4(message.mrrByPlan, reader, options);
                    break;
                case /* int64 active_subscriptions */ 5:
                    message.activeSubscriptions = reader.int64().toString();
                    break;
                case /* int64 trial_subscriptions */ 6:
                    message.trialSubscriptions = reader.int64().toString();
                    break;
                case /* int64 paused_subscriptions */ 7:
                    message.pausedSubscriptions = reader.int64().toString();
                    break;
                case /* int64 cancelled_subscriptions */ 8:
                    message.cancelledSubscriptions = reader.int64().toString();
                    break;
                case /* double churn_rate */ 9:
                    message.churnRate = reader.double();
                    break;
                case /* int64 churned_count */ 10:
                    message.churnedCount = reader.int64().toString();
                    break;
                case /* map<string, int64> churn_reasons */ 11:
                    this.binaryReadMap11(message.churnReasons, reader, options);
                    break;
                case /* int64 revenue */ 12:
                    message.revenue = reader.int64().toString();
                    break;
                case /* double revenue_growth */ 13:
                    message.revenueGrowth = reader.double();
                    break;
                case /* map<string, int64> revenue_by_plan */ 14:
                    this.binaryReadMap14(message.revenueByPlan, reader, options);
                    break;
                case /* double payment_success_rate */ 15:
                    message.paymentSuccessRate = reader.double();
                    break;
                case /* int64 total_payments */ 16:
                    message.totalPayments = reader.int64().toString();
                    break;
                case /* int64 successful_payments */ 17:
                    message.successfulPayments = reader.int64().toString();
                    break;
                case /* int64 failed_payments */ 18:
                    message.failedPayments = reader.int64().toString();
                    break;
                case /* int64 total_customers */ 19:
                    message.totalCustomers = reader.int64().toString();
                    break;
                case /* int64 new_customers */ 20:
                    message.newCustomers = reader.int64().toString();
                    break;
                case /* int64 average_lifetime_value */ 21:
                    message.averageLifetimeValue = reader.int64().toString();
                    break;
                case /* string period_start */ 22:
                    message.periodStart = reader.string();
                    break;
                case /* string period_end */ 23:
                    message.periodEnd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: AnalyticsMetrics["mrrByPlan"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AnalyticsMetrics["mrrByPlan"] | undefined, val: AnalyticsMetrics["mrrByPlan"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.AnalyticsMetrics.mrr_by_plan");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    private binaryReadMap11(map: AnalyticsMetrics["churnReasons"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AnalyticsMetrics["churnReasons"] | undefined, val: AnalyticsMetrics["churnReasons"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.AnalyticsMetrics.churn_reasons");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    private binaryReadMap14(map: AnalyticsMetrics["revenueByPlan"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AnalyticsMetrics["revenueByPlan"] | undefined, val: AnalyticsMetrics["revenueByPlan"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.AnalyticsMetrics.revenue_by_plan");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    internalBinaryWrite(message: AnalyticsMetrics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 mrr = 1; */
        if (message.mrr !== "0")
            writer.tag(1, WireType.Varint).int64(message.mrr);
        /* int64 arr = 2; */
        if (message.arr !== "0")
            writer.tag(2, WireType.Varint).int64(message.arr);
        /* double mrr_growth = 3; */
        if (message.mrrGrowth !== 0)
            writer.tag(3, WireType.Bit64).double(message.mrrGrowth);
        /* map<string, int64> mrr_by_plan = 4; */
        for (let k of globalThis.Object.keys(message.mrrByPlan))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.mrrByPlan[k]).join();
        /* int64 active_subscriptions = 5; */
        if (message.activeSubscriptions !== "0")
            writer.tag(5, WireType.Varint).int64(message.activeSubscriptions);
        /* int64 trial_subscriptions = 6; */
        if (message.trialSubscriptions !== "0")
            writer.tag(6, WireType.Varint).int64(message.trialSubscriptions);
        /* int64 paused_subscriptions = 7; */
        if (message.pausedSubscriptions !== "0")
            writer.tag(7, WireType.Varint).int64(message.pausedSubscriptions);
        /* int64 cancelled_subscriptions = 8; */
        if (message.cancelledSubscriptions !== "0")
            writer.tag(8, WireType.Varint).int64(message.cancelledSubscriptions);
        /* double churn_rate = 9; */
        if (message.churnRate !== 0)
            writer.tag(9, WireType.Bit64).double(message.churnRate);
        /* int64 churned_count = 10; */
        if (message.churnedCount !== "0")
            writer.tag(10, WireType.Varint).int64(message.churnedCount);
        /* map<string, int64> churn_reasons = 11; */
        for (let k of globalThis.Object.keys(message.churnReasons))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.churnReasons[k]).join();
        /* int64 revenue = 12; */
        if (message.revenue !== "0")
            writer.tag(12, WireType.Varint).int64(message.revenue);
        /* double revenue_growth = 13; */
        if (message.revenueGrowth !== 0)
            writer.tag(13, WireType.Bit64).double(message.revenueGrowth);
        /* map<string, int64> revenue_by_plan = 14; */
        for (let k of globalThis.Object.keys(message.revenueByPlan))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.revenueByPlan[k]).join();
        /* double payment_success_rate = 15; */
        if (message.paymentSuccessRate !== 0)
            writer.tag(15, WireType.Bit64).double(message.paymentSuccessRate);
        /* int64 total_payments = 16; */
        if (message.totalPayments !== "0")
            writer.tag(16, WireType.Varint).int64(message.totalPayments);
        /* int64 successful_payments = 17; */
        if (message.successfulPayments !== "0")
            writer.tag(17, WireType.Varint).int64(message.successfulPayments);
        /* int64 failed_payments = 18; */
        if (message.failedPayments !== "0")
            writer.tag(18, WireType.Varint).int64(message.failedPayments);
        /* int64 total_customers = 19; */
        if (message.totalCustomers !== "0")
            writer.tag(19, WireType.Varint).int64(message.totalCustomers);
        /* int64 new_customers = 20; */
        if (message.newCustomers !== "0")
            writer.tag(20, WireType.Varint).int64(message.newCustomers);
        /* int64 average_lifetime_value = 21; */
        if (message.averageLifetimeValue !== "0")
            writer.tag(21, WireType.Varint).int64(message.averageLifetimeValue);
        /* string period_start = 22; */
        if (message.periodStart !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.periodStart);
        /* string period_end = 23; */
        if (message.periodEnd !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.periodEnd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.AnalyticsMetrics
 */
export const AnalyticsMetrics = new AnalyticsMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CohortAnalysis$Type extends MessageType<CohortAnalysis> {
    constructor() {
        super("payments.CohortAnalysis", [
            { no: 1, name: "cohort_month", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "initial_size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "retention", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } },
            { no: 4, name: "revenue", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "average_revenue", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<CohortAnalysis>): CohortAnalysis {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cohortMonth = "";
        message.initialSize = "0";
        message.retention = {};
        message.revenue = "0";
        message.averageRevenue = 0;
        if (value !== undefined)
            reflectionMergePartial<CohortAnalysis>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CohortAnalysis): CohortAnalysis {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cohort_month */ 1:
                    message.cohortMonth = reader.string();
                    break;
                case /* int64 initial_size */ 2:
                    message.initialSize = reader.int64().toString();
                    break;
                case /* map<int32, double> retention */ 3:
                    this.binaryReadMap3(message.retention, reader, options);
                    break;
                case /* int64 revenue */ 4:
                    message.revenue = reader.int64().toString();
                    break;
                case /* double average_revenue */ 5:
                    message.averageRevenue = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: CohortAnalysis["retention"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CohortAnalysis["retention"] | undefined, val: CohortAnalysis["retention"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payments.CohortAnalysis.retention");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: CohortAnalysis, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cohort_month = 1; */
        if (message.cohortMonth !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cohortMonth);
        /* int64 initial_size = 2; */
        if (message.initialSize !== "0")
            writer.tag(2, WireType.Varint).int64(message.initialSize);
        /* map<int32, double> retention = 3; */
        for (let k of globalThis.Object.keys(message.retention))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit64).double(message.retention[k as any]).join();
        /* int64 revenue = 4; */
        if (message.revenue !== "0")
            writer.tag(4, WireType.Varint).int64(message.revenue);
        /* double average_revenue = 5; */
        if (message.averageRevenue !== 0)
            writer.tag(5, WireType.Bit64).double(message.averageRevenue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.CohortAnalysis
 */
export const CohortAnalysis = new CohortAnalysis$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RevenueForecast$Type extends MessageType<RevenueForecast> {
    constructor() {
        super("payments.RevenueForecast", [
            { no: 1, name: "month", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "projected_revenue", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "lower_bound", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "upper_bound", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "confidence", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<RevenueForecast>): RevenueForecast {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.month = "";
        message.projectedRevenue = "0";
        message.lowerBound = "0";
        message.upperBound = "0";
        message.confidence = 0;
        if (value !== undefined)
            reflectionMergePartial<RevenueForecast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RevenueForecast): RevenueForecast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string month */ 1:
                    message.month = reader.string();
                    break;
                case /* int64 projected_revenue */ 2:
                    message.projectedRevenue = reader.int64().toString();
                    break;
                case /* int64 lower_bound */ 3:
                    message.lowerBound = reader.int64().toString();
                    break;
                case /* int64 upper_bound */ 4:
                    message.upperBound = reader.int64().toString();
                    break;
                case /* double confidence */ 5:
                    message.confidence = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RevenueForecast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string month = 1; */
        if (message.month !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.month);
        /* int64 projected_revenue = 2; */
        if (message.projectedRevenue !== "0")
            writer.tag(2, WireType.Varint).int64(message.projectedRevenue);
        /* int64 lower_bound = 3; */
        if (message.lowerBound !== "0")
            writer.tag(3, WireType.Varint).int64(message.lowerBound);
        /* int64 upper_bound = 4; */
        if (message.upperBound !== "0")
            writer.tag(4, WireType.Varint).int64(message.upperBound);
        /* double confidence = 5; */
        if (message.confidence !== 0)
            writer.tag(5, WireType.Bit64).double(message.confidence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.RevenueForecast
 */
export const RevenueForecast = new RevenueForecast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserAnalytics$Type extends MessageType<UserAnalytics> {
    constructor() {
        super("payments.UserAnalytics", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total_spent", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "lifetime_value", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "subscription_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "active_subscriptions", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "payment_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "successful_payments", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "failed_payments", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "payment_success_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "first_subscription", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "days_since_first", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "average_monthly_spend", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<UserAnalytics>): UserAnalytics {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.totalSpent = "0";
        message.lifetimeValue = "0";
        message.subscriptionCount = 0;
        message.activeSubscriptions = 0;
        message.paymentCount = 0;
        message.successfulPayments = 0;
        message.failedPayments = 0;
        message.paymentSuccessRate = 0;
        message.firstSubscription = "";
        message.daysSinceFirst = 0;
        message.averageMonthlySpend = "0";
        if (value !== undefined)
            reflectionMergePartial<UserAnalytics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserAnalytics): UserAnalytics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* int64 total_spent */ 2:
                    message.totalSpent = reader.int64().toString();
                    break;
                case /* int64 lifetime_value */ 3:
                    message.lifetimeValue = reader.int64().toString();
                    break;
                case /* int32 subscription_count */ 4:
                    message.subscriptionCount = reader.int32();
                    break;
                case /* int32 active_subscriptions */ 5:
                    message.activeSubscriptions = reader.int32();
                    break;
                case /* int32 payment_count */ 6:
                    message.paymentCount = reader.int32();
                    break;
                case /* int32 successful_payments */ 7:
                    message.successfulPayments = reader.int32();
                    break;
                case /* int32 failed_payments */ 8:
                    message.failedPayments = reader.int32();
                    break;
                case /* double payment_success_rate */ 9:
                    message.paymentSuccessRate = reader.double();
                    break;
                case /* string first_subscription */ 10:
                    message.firstSubscription = reader.string();
                    break;
                case /* int32 days_since_first */ 11:
                    message.daysSinceFirst = reader.int32();
                    break;
                case /* int64 average_monthly_spend */ 12:
                    message.averageMonthlySpend = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserAnalytics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* int64 total_spent = 2; */
        if (message.totalSpent !== "0")
            writer.tag(2, WireType.Varint).int64(message.totalSpent);
        /* int64 lifetime_value = 3; */
        if (message.lifetimeValue !== "0")
            writer.tag(3, WireType.Varint).int64(message.lifetimeValue);
        /* int32 subscription_count = 4; */
        if (message.subscriptionCount !== 0)
            writer.tag(4, WireType.Varint).int32(message.subscriptionCount);
        /* int32 active_subscriptions = 5; */
        if (message.activeSubscriptions !== 0)
            writer.tag(5, WireType.Varint).int32(message.activeSubscriptions);
        /* int32 payment_count = 6; */
        if (message.paymentCount !== 0)
            writer.tag(6, WireType.Varint).int32(message.paymentCount);
        /* int32 successful_payments = 7; */
        if (message.successfulPayments !== 0)
            writer.tag(7, WireType.Varint).int32(message.successfulPayments);
        /* int32 failed_payments = 8; */
        if (message.failedPayments !== 0)
            writer.tag(8, WireType.Varint).int32(message.failedPayments);
        /* double payment_success_rate = 9; */
        if (message.paymentSuccessRate !== 0)
            writer.tag(9, WireType.Bit64).double(message.paymentSuccessRate);
        /* string first_subscription = 10; */
        if (message.firstSubscription !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.firstSubscription);
        /* int32 days_since_first = 11; */
        if (message.daysSinceFirst !== 0)
            writer.tag(11, WireType.Varint).int32(message.daysSinceFirst);
        /* int64 average_monthly_spend = 12; */
        if (message.averageMonthlySpend !== "0")
            writer.tag(12, WireType.Varint).int64(message.averageMonthlySpend);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.UserAnalytics
 */
export const UserAnalytics = new UserAnalytics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddPaymentMethodRequest$Type extends MessageType<AddPaymentMethodRequest> {
    constructor() {
        super("payments.AddPaymentMethodRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "phone_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "card_last4", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "card_brand", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "card_exp_month", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "card_exp_year", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "is_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AddPaymentMethodRequest>): AddPaymentMethodRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.type = "";
        message.phoneNumber = "";
        message.cardLast4 = "";
        message.cardBrand = "";
        message.cardExpMonth = 0;
        message.cardExpYear = 0;
        message.nickname = "";
        message.isDefault = false;
        if (value !== undefined)
            reflectionMergePartial<AddPaymentMethodRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddPaymentMethodRequest): AddPaymentMethodRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string phone_number */ 3:
                    message.phoneNumber = reader.string();
                    break;
                case /* string card_last4 */ 4:
                    message.cardLast4 = reader.string();
                    break;
                case /* string card_brand */ 5:
                    message.cardBrand = reader.string();
                    break;
                case /* int32 card_exp_month */ 6:
                    message.cardExpMonth = reader.int32();
                    break;
                case /* int32 card_exp_year */ 7:
                    message.cardExpYear = reader.int32();
                    break;
                case /* string nickname */ 8:
                    message.nickname = reader.string();
                    break;
                case /* bool is_default */ 9:
                    message.isDefault = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddPaymentMethodRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string phone_number = 3; */
        if (message.phoneNumber !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.phoneNumber);
        /* string card_last4 = 4; */
        if (message.cardLast4 !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cardLast4);
        /* string card_brand = 5; */
        if (message.cardBrand !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cardBrand);
        /* int32 card_exp_month = 6; */
        if (message.cardExpMonth !== 0)
            writer.tag(6, WireType.Varint).int32(message.cardExpMonth);
        /* int32 card_exp_year = 7; */
        if (message.cardExpYear !== 0)
            writer.tag(7, WireType.Varint).int32(message.cardExpYear);
        /* string nickname = 8; */
        if (message.nickname !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.nickname);
        /* bool is_default = 9; */
        if (message.isDefault !== false)
            writer.tag(9, WireType.Varint).bool(message.isDefault);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.AddPaymentMethodRequest
 */
export const AddPaymentMethodRequest = new AddPaymentMethodRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddPaymentMethodResponse$Type extends MessageType<AddPaymentMethodResponse> {
    constructor() {
        super("payments.AddPaymentMethodResponse", [
            { no: 1, name: "payment_method", kind: "message", T: () => PaymentMethod },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddPaymentMethodResponse>): AddPaymentMethodResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<AddPaymentMethodResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddPaymentMethodResponse): AddPaymentMethodResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.PaymentMethod payment_method */ 1:
                    message.paymentMethod = PaymentMethod.internalBinaryRead(reader, reader.uint32(), options, message.paymentMethod);
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddPaymentMethodResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.PaymentMethod payment_method = 1; */
        if (message.paymentMethod)
            PaymentMethod.internalBinaryWrite(message.paymentMethod, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.AddPaymentMethodResponse
 */
export const AddPaymentMethodResponse = new AddPaymentMethodResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaymentMethodsRequest$Type extends MessageType<GetPaymentMethodsRequest> {
    constructor() {
        super("payments.GetPaymentMethodsRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPaymentMethodsRequest>): GetPaymentMethodsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaymentMethodsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaymentMethodsRequest): GetPaymentMethodsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaymentMethodsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPaymentMethodsRequest
 */
export const GetPaymentMethodsRequest = new GetPaymentMethodsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaymentMethodsResponse$Type extends MessageType<GetPaymentMethodsResponse> {
    constructor() {
        super("payments.GetPaymentMethodsResponse", [
            { no: 1, name: "payment_methods", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PaymentMethod }
        ]);
    }
    create(value?: PartialMessage<GetPaymentMethodsResponse>): GetPaymentMethodsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paymentMethods = [];
        if (value !== undefined)
            reflectionMergePartial<GetPaymentMethodsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaymentMethodsResponse): GetPaymentMethodsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payments.PaymentMethod payment_methods */ 1:
                    message.paymentMethods.push(PaymentMethod.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaymentMethodsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payments.PaymentMethod payment_methods = 1; */
        for (let i = 0; i < message.paymentMethods.length; i++)
            PaymentMethod.internalBinaryWrite(message.paymentMethods[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetPaymentMethodsResponse
 */
export const GetPaymentMethodsResponse = new GetPaymentMethodsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDefaultPaymentMethodRequest$Type extends MessageType<GetDefaultPaymentMethodRequest> {
    constructor() {
        super("payments.GetDefaultPaymentMethodRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDefaultPaymentMethodRequest>): GetDefaultPaymentMethodRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetDefaultPaymentMethodRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDefaultPaymentMethodRequest): GetDefaultPaymentMethodRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDefaultPaymentMethodRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetDefaultPaymentMethodRequest
 */
export const GetDefaultPaymentMethodRequest = new GetDefaultPaymentMethodRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDefaultPaymentMethodResponse$Type extends MessageType<GetDefaultPaymentMethodResponse> {
    constructor() {
        super("payments.GetDefaultPaymentMethodResponse", [
            { no: 1, name: "payment_method", kind: "message", T: () => PaymentMethod }
        ]);
    }
    create(value?: PartialMessage<GetDefaultPaymentMethodResponse>): GetDefaultPaymentMethodResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDefaultPaymentMethodResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDefaultPaymentMethodResponse): GetDefaultPaymentMethodResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.PaymentMethod payment_method */ 1:
                    message.paymentMethod = PaymentMethod.internalBinaryRead(reader, reader.uint32(), options, message.paymentMethod);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDefaultPaymentMethodResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.PaymentMethod payment_method = 1; */
        if (message.paymentMethod)
            PaymentMethod.internalBinaryWrite(message.paymentMethod, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.GetDefaultPaymentMethodResponse
 */
export const GetDefaultPaymentMethodResponse = new GetDefaultPaymentMethodResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetDefaultPaymentMethodRequest$Type extends MessageType<SetDefaultPaymentMethodRequest> {
    constructor() {
        super("payments.SetDefaultPaymentMethodRequest", [
            { no: 1, name: "method_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetDefaultPaymentMethodRequest>): SetDefaultPaymentMethodRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.methodId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<SetDefaultPaymentMethodRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetDefaultPaymentMethodRequest): SetDefaultPaymentMethodRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string method_id */ 1:
                    message.methodId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetDefaultPaymentMethodRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string method_id = 1; */
        if (message.methodId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.methodId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.SetDefaultPaymentMethodRequest
 */
export const SetDefaultPaymentMethodRequest = new SetDefaultPaymentMethodRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetDefaultPaymentMethodResponse$Type extends MessageType<SetDefaultPaymentMethodResponse> {
    constructor() {
        super("payments.SetDefaultPaymentMethodResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetDefaultPaymentMethodResponse>): SetDefaultPaymentMethodResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<SetDefaultPaymentMethodResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetDefaultPaymentMethodResponse): SetDefaultPaymentMethodResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetDefaultPaymentMethodResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.SetDefaultPaymentMethodResponse
 */
export const SetDefaultPaymentMethodResponse = new SetDefaultPaymentMethodResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemovePaymentMethodRequest$Type extends MessageType<RemovePaymentMethodRequest> {
    constructor() {
        super("payments.RemovePaymentMethodRequest", [
            { no: 1, name: "method_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemovePaymentMethodRequest>): RemovePaymentMethodRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.methodId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<RemovePaymentMethodRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemovePaymentMethodRequest): RemovePaymentMethodRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string method_id */ 1:
                    message.methodId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemovePaymentMethodRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string method_id = 1; */
        if (message.methodId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.methodId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.RemovePaymentMethodRequest
 */
export const RemovePaymentMethodRequest = new RemovePaymentMethodRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemovePaymentMethodResponse$Type extends MessageType<RemovePaymentMethodResponse> {
    constructor() {
        super("payments.RemovePaymentMethodResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemovePaymentMethodResponse>): RemovePaymentMethodResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<RemovePaymentMethodResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemovePaymentMethodResponse): RemovePaymentMethodResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemovePaymentMethodResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.RemovePaymentMethodResponse
 */
export const RemovePaymentMethodResponse = new RemovePaymentMethodResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePaymentMethodNicknameRequest$Type extends MessageType<UpdatePaymentMethodNicknameRequest> {
    constructor() {
        super("payments.UpdatePaymentMethodNicknameRequest", [
            { no: 1, name: "method_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePaymentMethodNicknameRequest>): UpdatePaymentMethodNicknameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.methodId = "";
        message.userId = "";
        message.nickname = "";
        if (value !== undefined)
            reflectionMergePartial<UpdatePaymentMethodNicknameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePaymentMethodNicknameRequest): UpdatePaymentMethodNicknameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string method_id */ 1:
                    message.methodId = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                case /* string nickname */ 3:
                    message.nickname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePaymentMethodNicknameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string method_id = 1; */
        if (message.methodId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.methodId);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string nickname = 3; */
        if (message.nickname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nickname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.UpdatePaymentMethodNicknameRequest
 */
export const UpdatePaymentMethodNicknameRequest = new UpdatePaymentMethodNicknameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePaymentMethodNicknameResponse$Type extends MessageType<UpdatePaymentMethodNicknameResponse> {
    constructor() {
        super("payments.UpdatePaymentMethodNicknameResponse", [
            { no: 1, name: "payment_method", kind: "message", T: () => PaymentMethod },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePaymentMethodNicknameResponse>): UpdatePaymentMethodNicknameResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<UpdatePaymentMethodNicknameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePaymentMethodNicknameResponse): UpdatePaymentMethodNicknameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payments.PaymentMethod payment_method */ 1:
                    message.paymentMethod = PaymentMethod.internalBinaryRead(reader, reader.uint32(), options, message.paymentMethod);
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePaymentMethodNicknameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payments.PaymentMethod payment_method = 1; */
        if (message.paymentMethod)
            PaymentMethod.internalBinaryWrite(message.paymentMethod, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.UpdatePaymentMethodNicknameResponse
 */
export const UpdatePaymentMethodNicknameResponse = new UpdatePaymentMethodNicknameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaymentMethod$Type extends MessageType<PaymentMethod> {
    constructor() {
        super("payments.PaymentMethod", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "phone_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "card_last4", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "card_brand", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "card_exp_month", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "card_exp_year", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "is_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "is_expired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "last_used_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PaymentMethod>): PaymentMethod {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.type = "";
        message.phoneNumber = "";
        message.cardLast4 = "";
        message.cardBrand = "";
        message.cardExpMonth = 0;
        message.cardExpYear = 0;
        message.nickname = "";
        message.isDefault = false;
        message.isExpired = false;
        message.createdAt = "";
        message.lastUsedAt = "";
        if (value !== undefined)
            reflectionMergePartial<PaymentMethod>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaymentMethod): PaymentMethod {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string phone_number */ 3:
                    message.phoneNumber = reader.string();
                    break;
                case /* string card_last4 */ 4:
                    message.cardLast4 = reader.string();
                    break;
                case /* string card_brand */ 5:
                    message.cardBrand = reader.string();
                    break;
                case /* int32 card_exp_month */ 6:
                    message.cardExpMonth = reader.int32();
                    break;
                case /* int32 card_exp_year */ 7:
                    message.cardExpYear = reader.int32();
                    break;
                case /* string nickname */ 8:
                    message.nickname = reader.string();
                    break;
                case /* bool is_default */ 9:
                    message.isDefault = reader.bool();
                    break;
                case /* bool is_expired */ 10:
                    message.isExpired = reader.bool();
                    break;
                case /* string created_at */ 11:
                    message.createdAt = reader.string();
                    break;
                case /* string last_used_at */ 12:
                    message.lastUsedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaymentMethod, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string phone_number = 3; */
        if (message.phoneNumber !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.phoneNumber);
        /* string card_last4 = 4; */
        if (message.cardLast4 !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cardLast4);
        /* string card_brand = 5; */
        if (message.cardBrand !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cardBrand);
        /* int32 card_exp_month = 6; */
        if (message.cardExpMonth !== 0)
            writer.tag(6, WireType.Varint).int32(message.cardExpMonth);
        /* int32 card_exp_year = 7; */
        if (message.cardExpYear !== 0)
            writer.tag(7, WireType.Varint).int32(message.cardExpYear);
        /* string nickname = 8; */
        if (message.nickname !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.nickname);
        /* bool is_default = 9; */
        if (message.isDefault !== false)
            writer.tag(9, WireType.Varint).bool(message.isDefault);
        /* bool is_expired = 10; */
        if (message.isExpired !== false)
            writer.tag(10, WireType.Varint).bool(message.isExpired);
        /* string created_at = 11; */
        if (message.createdAt !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.createdAt);
        /* string last_used_at = 12; */
        if (message.lastUsedAt !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.lastUsedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payments.PaymentMethod
 */
export const PaymentMethod = new PaymentMethod$Type();
/**
 * @generated ServiceType for protobuf service payments.PaymentsService
 */
export const PaymentsService = new ServiceType("payments.PaymentsService", [
    { name: "GetPlans", options: {}, I: GetPlansRequest, O: GetPlansResponse },
    { name: "GetPlan", options: {}, I: GetPlanRequest, O: GetPlanResponse },
    { name: "CreateSubscription", options: {}, I: CreateSubscriptionRequest, O: CreateSubscriptionResponse },
    { name: "GetSubscription", options: {}, I: GetSubscriptionRequest, O: GetSubscriptionResponse },
    { name: "GetMySubscription", options: {}, I: GetMySubscriptionRequest, O: GetMySubscriptionResponse },
    { name: "ListMySubscriptions", options: {}, I: ListMySubscriptionsRequest, O: ListMySubscriptionsResponse },
    { name: "CancelSubscription", options: {}, I: CancelSubscriptionRequest, O: CancelSubscriptionResponse },
    { name: "CheckSubscriptionAccess", options: {}, I: CheckSubscriptionAccessRequest, O: CheckSubscriptionAccessResponse },
    { name: "PauseSubscription", options: {}, I: PauseSubscriptionRequest, O: PauseSubscriptionResponse },
    { name: "ResumeSubscription", options: {}, I: ResumeSubscriptionRequest, O: ResumeSubscriptionResponse },
    { name: "GetPauseStatus", options: {}, I: GetPauseStatusRequest, O: GetPauseStatusResponse },
    { name: "InitiateCancellation", options: {}, I: InitiateCancellationRequest, O: InitiateCancellationResponse },
    { name: "AcceptRetentionOffer", options: {}, I: AcceptRetentionOfferRequest, O: AcceptRetentionOfferResponse },
    { name: "ConfirmCancellation", options: {}, I: ConfirmCancellationRequest, O: ConfirmCancellationResponse },
    { name: "UndoCancellation", options: {}, I: UndoCancellationRequest, O: UndoCancellationResponse },
    { name: "GetCancellationStatus", options: {}, I: GetCancellationStatusRequest, O: GetCancellationStatusResponse },
    { name: "CreateSubscriptionCheckout", options: {}, I: CreateSubscriptionCheckoutRequest, O: CreateSubscriptionCheckoutResponse },
    { name: "InitiatePayment", options: {}, I: InitiatePaymentRequest, O: InitiatePaymentResponse },
    { name: "GetPayment", options: {}, I: GetPaymentRequest, O: GetPaymentResponse },
    { name: "ListMyPayments", options: {}, I: ListMyPaymentsRequest, O: ListMyPaymentsResponse },
    { name: "CheckPaymentStatus", options: {}, I: CheckPaymentStatusRequest, O: CheckPaymentStatusResponse },
    { name: "DownloadReceipt", options: {}, I: DownloadReceiptRequest, O: DownloadReceiptResponse },
    { name: "EmailReceipt", options: {}, I: EmailReceiptRequest, O: EmailReceiptResponse },
    { name: "PreviewProration", options: {}, I: PreviewProrationRequest, O: PreviewProrationResponse },
    { name: "ChangePlan", options: {}, I: ChangePlanRequest, O: ChangePlanResponse },
    { name: "GetProrationHistory", options: {}, I: GetProrationHistoryRequest, O: GetProrationHistoryResponse },
    { name: "GetCreditBalance", options: {}, I: GetCreditBalanceRequest, O: GetCreditBalanceResponse },
    { name: "GetFraudStats", options: {}, I: GetFraudStatsRequest, O: GetFraudStatsResponse },
    { name: "GetFlaggedUsers", options: {}, I: GetFlaggedUsersRequest, O: GetFlaggedUsersResponse },
    { name: "GetBlacklistedPhones", options: {}, I: GetBlacklistedPhonesRequest, O: GetBlacklistedPhonesResponse },
    { name: "GetBlacklistedIPs", options: {}, I: GetBlacklistedIPsRequest, O: GetBlacklistedIPsResponse },
    { name: "BlacklistPhone", options: {}, I: BlacklistPhoneRequest, O: BlacklistPhoneResponse },
    { name: "BlacklistIP", options: {}, I: BlacklistIPRequest, O: BlacklistIPResponse },
    { name: "RemovePhoneFromBlacklist", options: {}, I: RemovePhoneFromBlacklistRequest, O: RemovePhoneFromBlacklistResponse },
    { name: "RemoveIPFromBlacklist", options: {}, I: RemoveIPFromBlacklistRequest, O: RemoveIPFromBlacklistResponse },
    { name: "GetFraudRules", options: {}, I: GetFraudRulesRequest, O: GetFraudRulesResponse },
    { name: "UpdateFraudRule", options: {}, I: UpdateFraudRuleRequest, O: UpdateFraudRuleResponse },
    { name: "GetAnalytics", options: {}, I: GetAnalyticsRequest, O: GetAnalyticsResponse },
    { name: "GetMRRMetrics", options: {}, I: GetMRRMetricsRequest, O: GetMRRMetricsResponse },
    { name: "GetChurnMetrics", options: {}, I: GetChurnMetricsRequest, O: GetChurnMetricsResponse },
    { name: "GetRevenueMetrics", options: {}, I: GetRevenueMetricsRequest, O: GetRevenueMetricsResponse },
    { name: "GetCohortAnalysis", options: {}, I: GetCohortAnalysisRequest, O: GetCohortAnalysisResponse },
    { name: "ForecastRevenue", options: {}, I: ForecastRevenueRequest, O: ForecastRevenueResponse },
    { name: "GetUserAnalytics", options: {}, I: GetUserAnalyticsRequest, O: GetUserAnalyticsResponse },
    { name: "AddPaymentMethod", options: {}, I: AddPaymentMethodRequest, O: AddPaymentMethodResponse },
    { name: "GetPaymentMethods", options: {}, I: GetPaymentMethodsRequest, O: GetPaymentMethodsResponse },
    { name: "GetDefaultPaymentMethod", options: {}, I: GetDefaultPaymentMethodRequest, O: GetDefaultPaymentMethodResponse },
    { name: "SetDefaultPaymentMethod", options: {}, I: SetDefaultPaymentMethodRequest, O: SetDefaultPaymentMethodResponse },
    { name: "RemovePaymentMethod", options: {}, I: RemovePaymentMethodRequest, O: RemovePaymentMethodResponse },
    { name: "UpdatePaymentMethodNickname", options: {}, I: UpdatePaymentMethodNicknameRequest, O: UpdatePaymentMethodNicknameResponse }
]);
